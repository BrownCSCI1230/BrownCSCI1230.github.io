<!DOCTYPE html>
    <html lang="en">
      <head><link rel="stylesheet" type="text/css" href="/assets/index.0b80a650.css">
        <meta charset="UTF-8">
        <title>Lab 9 | CSCI 1230</title>
        <meta name="description" content="We teach computer graphics!">
        <meta name="keywords" content="Computer Science, Computer Graphics, CS 1230,CSCI 1230, Brown University, Providence">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
      </head>
      <body>
        <div id="root">
          <nav id="nav-bar"><div id="nav-bar-inner"><a id="logo" class="no-select" href="/" aria-label="home" style="--duration:450ms"><div id="logo-box-1"></div><div id="logo-box-2"></div><div id="logo-box-3"></div><div id="logo-box-4"></div><div id="logo-box-5"></div><div id="logo-box-6"></div></a><div id="nav-items"><a href="/" class="nav-item">Home</a><a href="/docs" class="nav-item">Docs</a><a href="/labs" class="nav-item">Labs</a><a href="/projects" class="nav-item">Projects</a></div></div></nav><div id="page" class=""><nav class="toc"><ol class="toc-level toc-level-1"><li class="toc-item toc-item-h1"><a class="toc-link toc-link-h1" href="#vbosvaos-lab">VBOs/VAOs Lab</a><ol class="toc-level toc-level-2"><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#intro">Intro</a><ol class="toc-level toc-level-3"><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#using-the-khronos-documentation">Using the Khronos Documentation</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#the-opengl-state-machine">The OpenGL State Machine</a></li></ol></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#vertex-buffer-objects">Vertex Buffer Objects</a><ol class="toc-level toc-level-3"><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#creating-a-vertex-buffer-object">Creating a Vertex Buffer Object</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#adding-data">Adding Data</a><ol class="toc-level toc-level-4"><li class="toc-item toc-item-h4"><a class="toc-link toc-link-h4" href="#binding-a-vbo">Binding a VBO</a></li><li class="toc-item toc-item-h4"><a class="toc-link toc-link-h4" href="#defining-a-triangle">Defining a Triangle</a></li><li class="toc-item toc-item-h4"><a class="toc-link toc-link-h4" href="#putting-data-into-a-vbo">Putting Data Into a VBO</a></li></ol></li></ol></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#vertex-array-objects">Vertex Array Objects</a><ol class="toc-level toc-level-3"><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#vertex-attributes">Vertex Attributes</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#creating-a-vao">Creating a VAO</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#binding-a-vao">Binding a VAO</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#utilizing-a-vao">Utilizing a VAO</a></li></ol></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#unbinding-objects">Unbinding Objects</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#drawing-in-opengl">Drawing in OpenGL</a><ol class="toc-level toc-level-3"><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#drawing-overview">Drawing Overview</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#the-gldrawarrays-call">The glDrawArrays Call</a></li></ol></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#memory-management">Memory Management</a></li></ol></li></ol></nav><main>
<!-- -->
<h1 id="vbosvaos-lab"><a href="#vbosvaos-lab">VBOs/VAOs Lab</a></h1>
<p>Welcome to the world of OpenGL!</p>
<p>In the last lab, you learned how to construct vertex data for various shapes and put them into a container as continuous floats.
What you didn’t know is that this representation is actually how OpenGL stores its vertex data as well!</p>
<p>By the end of this lab, you should be able to</p>
<ul>
<li>Understand the difference between a Vertex Buffer Object and a Vertex Array Object and their individual uses,</li>
<li>Learn about per-vertex attributes and layouts,</li>
<li>Draw triangle meshes (which you have been creating in the last lab!)</li>
</ul>
<h2 id="intro"><a href="#intro">Intro</a></h2>
<p>Currently, our data is stored in C++ structures on the <em>CPU</em>, but in this lab you will create OpenGL specific objects to both store and describe the data that
can be used for drawing on the <em>GPU</em>.</p>
<p>These objects are: <strong>Vertex Buffer Objects</strong> (<strong>VBOs</strong>) and <strong>Vertex Array Objects</strong> (<strong>VAOs</strong>).</p>
<figure id="figure-1" class="image-wrapper"><div class="image-grid" style="--target-width:95%"><img src="/labs/lab9/VBO_VAO_Overview.png" alt="TODO"/></div><figcaption><strong>Figure 1: </strong>Visualization of VBOs and VAOs</figcaption></figure>
<p>At the moment, you can imagine a VBO to be a dumb container, the same as a C++
vector that doesn’t have a clue about the meaning behind the data that is in it.</p>
<p>The VAO on the other hand acts as a translation manual for the GPU to understand
what data and what format of data is inside a Vertex Buffer Object.</p>
<p>While VAO has &quot;array&quot; in its name, a VAO is <strong>NOT</strong> an array of vertex values. Instead,
it can represent an array of <em>properties</em> or <em>attributes</em> of our VBO. Each entry in
this array contains information about where this attribute is located in the VBO.</p>
<h3 id="using-the-khronos-documentation"><a href="#using-the-khronos-documentation">Using the Khronos Documentation</a></h3>
<p>Before we jump into learning a new API, it always is good practice to explore its documentation!</p>
<p>Most APIs come with some form of documentation on how you can use them.
OpenGL is no exception, as a matter of fact, OpenGL is made by the Khronos
group (who now is also developing the Vulkan API) and has extensive documentation
on any functions across any version of OpenGL you may use.</p>
<p>The home page for OpenGL 3.1 is located
<a href="https://registry.khronos.org/OpenGL-Refpages/es3.1/">here</a>.</p>
<p>While our projects are set up to use OpenGL 4.1, the functions we will be using
are within OpenGL 3.1.</p>
<p>Let’s take a look at a function to see what the docs tell us about it!</p>
<div class="task-callout callout"><p>Find the function <code>glGetError</code> and open its documentation.</p></div>
<p>Notice the different sections. The first section, <strong>Name</strong>, says the function name along
with a short description of what the function is. This is useful if you want to quickly
browse for a reminder, but often if you are looking at new functions, you will have
to dig deeper.</p>
<p>The second section, <strong>C Specification</strong> says the particular syntax of the function in question.</p>
<p>In cases where a function has input parameters, there will be an intermediate section
titled <strong>Parameters</strong> which gives short descriptions of each input parameter and occasionally
what values they can take on.</p>
<p>The third section, <strong>Description</strong>, gives you much more information about how the function
is used and sometimes information about the parameters in question such as OpenGL error
enums as we see here!</p>
<p>The fourth section, <strong>API Version Support</strong>, tells us in which OpenGL versions this function
can be called. Be aware of this if you are trying to use modern OpenGL functions but any
we cover here will be supported by the stencil’s OpenGL version.</p>
<p>Through this lab and your work in OpenGL, we strongly recommend having the docs open in
another tab to reference, and each function signature will serve as a link to their
relevant page in the docs.</p>
<h3 id="the-opengl-state-machine"><a href="#the-opengl-state-machine">The OpenGL State Machine</a></h3>
<p>Instead of defining a bunch of instances of objects and calling functions on them directly,
OpenGL functions as a <strong>state machine</strong>. This means that you keep track of some overarching
meta-object with different settings and conditions which affects every operation you do.
In OpenGL, this meta-object is called the <strong>context</strong>.
In this way, you will have to change your programming mindset when looking at OpenGL
functions. In fact, there are 2 &quot;genres&quot; of functions you will generally work with:</p>
<ol>
<li><strong>State Setting</strong>. This indicates a function changes the state of the current OpenGL
context.</li>
<li><strong>State Using</strong>. This indicates a function uses the current state parameters in order
to achieve an output.</li>
</ol>
<p>Just how action and comedy came together to bring us the Spy Kids film franchise, these function &quot;genres&quot; are
<strong>NOT</strong> mutually exclusive and some functions will do both!</p>
<p>Because of this unique behavior, it is important to be careful about managing OpenGL’s
state during the execution of your programs. There are two strategies for this:</p>
<ol>
<li><strong>Assume Nothing</strong>. When writing a function that uses OpenGL, consider that the state could
be anything. Explicitly set the values of the state parameters you depend on.</li>
<li><strong>Default Configuration</strong>. Decide on a set of reasonable default state values, and set the
state to these values at the start of your application. Anywhere you change one of these
state parameters, restore the parameter to its previous value after you’re done rendering a component of the scene.</li>
</ol>
<p>For the purposes of these labs, we will primarily be using the second option, which you will
get more experience with in section 4.</p>
<figure id="figure-2" class="image-wrapper"><div class="image-grid" style="--target-width:95%"><img src="/labs/lab9/State_Machine.png" alt="TODO"/></div><figcaption><strong>Figure 2: </strong>Visualization of OpenGL State Machine</figcaption></figure>
<blockquote>
<p>Note: Through this lab, you will primarily be working in the glRenderer.cpp file!</p>
</blockquote>
<div class="task-callout callout"><p>Search the docs for the <code>glClearColor</code> function and call at the start of <code>initializeGL</code>
to <strong>set our default state</strong> and change the background color to anything you like! Run the program
to see what it does.</p></div>
<h2 id="vertex-buffer-objects"><a href="#vertex-buffer-objects">Vertex Buffer Objects</a></h2>
<p>Typically, shapes in OpenGL are broken down into a collection of triangles, each of which
is defined by three vertices. So far, we have been processing all of our scene data on
the CPU, but in order to draw using OpenGL, we need to send a list of vertices to the GPU.</p>
<p>To send this data, we need some sort of container or buffer to store it first. In
OpenGL, this generic container is called a <strong>Vertex Buffer Object</strong>, or <strong>VBO</strong> for short.
The key to VBOs is to remember that they are just mindless containers that store
numbers and nothing more. They have no idea of what they contain or what it will be
used for. In this lab we will learn about how to create one of these VBOs and use it
to later draw shapes of our own!</p>
<h3 id="creating-a-vertex-buffer-object"><a href="#creating-a-vertex-buffer-object">Creating a Vertex Buffer Object</a></h3>
<p>Let’s take a look at how you would actually create a VBO. The OpenGL function is as follows:</p>
<div class="success-callout callout"><p style="text-align:center"><blockquote>
<p><a href="https://registry.khronos.org/OpenGL-Refpages/es3.1/html/glGenBuffers.xhtml"><strong>void glGenBuffers(GLsizei n, GLuint *buffers);</strong></a></p>
</blockquote></p><p><strong><code>n</code> :</strong> This indicates the number of vertex buffer objects to create.
The type GLsizei is an OpenGL alias indicating it is an integer representing some size</p><p><strong><code>buffers</code> :</strong> This is the pointer this function will fill in with an id for the
generated buffer. This way you can refer to it later by the same stored id.
Multiple buffers can be filled in using a pointer to the first element of an array of
sufficient size or some pointer followed by sufficient allocated space.
GLuint is an OpenGL alias for an unsigned int.</p></div>
<div class="task-callout callout"><p>Generate a single VBO in <code>InitializeGL</code> and store its id in <code>m_vbo</code>.</p></div>
<h3 id="adding-data"><a href="#adding-data">Adding Data</a></h3>
<h4 id="binding-a-vbo"><a href="#binding-a-vbo">Binding a VBO</a></h4>
<p>Congratulations, you have made a VBO! But…it currently holds no data! Let’s fix that.
As said before, OpenGL is a state machine, so in order to interact with our created
buffer, we need to bind it to the current state. The OpenGL function to do this is:</p>
<div class="success-callout callout"><p style="text-align:center"><blockquote>
<p><a href="https://registry.khronos.org/OpenGL-Refpages/es3.1/html/glBindBuffer.xhtml"><strong>void glBindBuffer(GLenum target, GLuint buffer);</strong></a></p>
</blockquote></p><p><strong><code>target</code> :</strong> This is an enumerable indicating which type of buffer you are binding. For
our purposes, use <code>GL_ARRAY_BUFFER</code>.</p><p><strong><code>buffer</code> :</strong> This indicates the specific buffer id that should be bound
(hint: remember the GLuint we created in the last step?)</p></div>
<div class="task-callout callout"><p>In <code>InitializeGL</code>, bind your previously created VBO.</p></div>
<p>Now our state is all set up to shove our data into our buffer container!
But before we do this, we actually need some data to put inside. Let’s construct
an array that represents a triangle.</p>
<h4 id="defining-a-triangle"><a href="#defining-a-triangle">Defining a Triangle</a></h4>
<p>A triangle as said before is defined by 3 vertices. For now, let’s assume that these
vertices are just positions, although in in the last lab you worked with vertex normals
and in part 2 you will learn about more attributes vertices can hold!</p>
<p>As a reminder in OpenGL, the screen is defined as in the image below:</p>
<figure id="figure-3" class="image-wrapper"><div class="image-grid" style="--target-width:95%"><img src="/labs/lab9/openglcoordinates.png" alt="TODO"/></div><figcaption><strong>Figure 3: </strong>OpenGL Coordinate System</figcaption></figure>
<p>Take note of the x and y ranges of -1 to 1. As a reminder: in OpenGL,
triangles are defined in a counter clockwise direction.</p>
<div class="task-callout callout"><p>Pick 3 points that would make a nice triangle. Make sure to pick z values of 0 as well!</p></div>
<h4 id="putting-data-into-a-vbo"><a href="#putting-data-into-a-vbo">Putting Data Into a VBO</a></h4>
<p>Now how will we actually put this information into our VBO? Let&#x27;s take a
look at the function to do so first:</p>
<div class="success-callout callout"><p style="text-align:center"><blockquote>
<p><a href="https://registry.khronos.org/OpenGL-Refpages/es3.1/html/glBufferData.xhtml"><strong>void glBufferData(GLenum target, GLsizeiptr size, const void *data, GLenum usage);</strong></a></p>
</blockquote></p><p><strong><code>target</code> :</strong> This is the same argument seen in glBindBuffer.</p><p><strong><code>size</code> :</strong> This indicates the size in bytes of the input data.</p><p><strong><code>data</code> :</strong> This is a pointer to the first element of the input data array.</p><p><strong><code>usage</code> :</strong> This is an OpenGL enum representing how the data will be used. For
our purposes, the usage parameter should be GL_STATIC_DRAW which indicates we don&#x27;t
expect to change the data, so OpenGL can make optimizations based on that.</p></div>
<p>Next let’s look at data. The function expects a pointer to an input data array,
but we don’t have that array yet! Let’s use an <code>std::vector</code> to construct our
data container. In OpenGL, rather than separating out values for each individual
vertex, it expects all of them mashed together into one contiguous collection as
you did in the previous lab, and the VAO you will learn about soon keeps track
of where the attributes are for us!</p>
<div class="task-callout callout"><p>In <code>InitializeGL</code>, construct an <code>std::vector</code> containing your three triangle points in a contiguous
series of floats.</p></div>
<p>Now to pass this into the function, we can use the <code>data()</code> method of the <code>std::vector</code>
object. This will return a pointer to the first element as needed.</p>
<p>For the size, while we can manually input the size of our data, it is much easier
to let the program calculate that for us. The size of our data is going to be equal to:</p>
<div class="math math-display"><mjx-container className="MathJax" jax="SVG" display="true"><svg style="vertical-align:-0.566ex" xmlns="http://www.w3.org/2000/svg" width="41.578ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 18377.4 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-1-TEX-N-6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path id="MJX-1-TEX-N-65" d="M28 218Q28 273 48 318T98 391T163 433T229 448Q282 448 320 430T378 380T406 316T415 245Q415 238 408 231H126V216Q126 68 226 36Q246 30 270 30Q312 30 342 62Q359 79 369 104L379 128Q382 131 395 131H398Q415 131 415 121Q415 117 412 108Q393 53 349 21T250 -11Q155 -11 92 58T28 218ZM333 275Q322 403 238 411H236Q228 411 220 410T195 402T166 381T143 340T127 274V267H333V275Z"></path><path id="MJX-1-TEX-N-6E" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q450 438 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z"></path><path id="MJX-1-TEX-N-67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z"></path><path id="MJX-1-TEX-N-74" d="M27 422Q80 426 109 478T141 600V615H181V431H316V385H181V241Q182 116 182 100T189 68Q203 29 238 29Q282 29 292 100Q293 108 293 146V181H333V146V134Q333 57 291 17Q264 -10 221 -10Q187 -10 162 2T124 33T105 68T98 100Q97 107 97 248V385H18V422H27Z"></path><path id="MJX-1-TEX-N-68" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 124T102 167T103 217T103 272T103 329Q103 366 103 407T103 482T102 542T102 586T102 603Q99 622 88 628T43 637H25V660Q25 683 27 683L37 684Q47 685 66 686T103 688Q120 689 140 690T170 693T181 694H184V367Q244 442 328 442Q451 442 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z"></path><path id="MJX-1-TEX-N-20" d=""></path><path id="MJX-1-TEX-N-6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z"></path><path id="MJX-1-TEX-N-66" d="M273 0Q255 3 146 3Q43 3 34 0H26V46H42Q70 46 91 49Q99 52 103 60Q104 62 104 224V385H33V431H104V497L105 564L107 574Q126 639 171 668T266 704Q267 704 275 704T289 705Q330 702 351 679T372 627Q372 604 358 590T321 576T284 590T270 627Q270 647 288 667H284Q280 668 273 668Q245 668 223 647T189 592Q183 572 182 497V431H293V385H185V225Q185 63 186 61T189 57T194 54T199 51T206 49T213 48T222 47T231 47T241 46T251 46H282V0H273Z"></path><path id="MJX-1-TEX-N-64" d="M376 495Q376 511 376 535T377 568Q377 613 367 624T316 637H298V660Q298 683 300 683L310 684Q320 685 339 686T376 688Q393 689 413 690T443 693T454 694H457V390Q457 84 458 81Q461 61 472 55T517 46H535V0Q533 0 459 -5T380 -11H373V44L365 37Q307 -11 235 -11Q158 -11 96 50T34 215Q34 315 97 378T244 442Q319 442 376 393V495ZM373 342Q328 405 260 405Q211 405 173 369Q146 341 139 305T131 211Q131 155 138 120T173 59Q203 26 251 26Q322 26 373 103V342Z"></path><path id="MJX-1-TEX-N-61" d="M137 305T115 305T78 320T63 359Q63 394 97 421T218 448Q291 448 336 416T396 340Q401 326 401 309T402 194V124Q402 76 407 58T428 40Q443 40 448 56T453 109V145H493V106Q492 66 490 59Q481 29 455 12T400 -6T353 12T329 54V58L327 55Q325 52 322 49T314 40T302 29T287 17T269 6T247 -2T221 -8T190 -11Q130 -11 82 20T34 107Q34 128 41 147T68 188T116 225T194 253T304 268H318V290Q318 324 312 340Q290 411 215 411Q197 411 181 410T156 406T148 403Q170 388 170 359Q170 334 154 320ZM126 106Q126 75 150 51T209 26Q247 26 276 49T315 109Q317 116 318 175Q318 233 317 233Q309 233 296 232T251 223T193 203T147 166T126 106Z"></path><path id="MJX-1-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path><path id="MJX-1-TEX-N-2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path><path id="MJX-1-TEX-N-73" d="M295 316Q295 356 268 385T190 414Q154 414 128 401Q98 382 98 349Q97 344 98 336T114 312T157 287Q175 282 201 278T245 269T277 256Q294 248 310 236T342 195T359 133Q359 71 321 31T198 -10H190Q138 -10 94 26L86 19L77 10Q71 4 65 -1L54 -11H46H42Q39 -11 33 -5V74V132Q33 153 35 157T45 162H54Q66 162 70 158T75 146T82 119T101 77Q136 26 198 26Q295 26 295 104Q295 133 277 151Q257 175 194 187T111 210Q75 227 54 256T33 318Q33 357 50 384T93 424T143 442T187 447H198Q238 447 268 432L283 424L292 431Q302 440 314 448H322H326Q329 448 335 442V310L329 304H301Q295 310 295 316Z"></path><path id="MJX-1-TEX-N-69" d="M69 609Q69 637 87 653T131 669Q154 667 171 652T188 609Q188 579 171 564T129 549Q104 549 87 564T69 609ZM247 0Q232 3 143 3Q132 3 106 3T56 1L34 0H26V46H42Q70 46 91 49Q100 53 102 60T104 102V205V293Q104 345 102 359T88 378Q74 385 41 385H30V408Q30 431 32 431L42 432Q52 433 70 434T106 436Q123 437 142 438T171 441T182 442H185V62Q190 52 197 50T232 46H255V0H247Z"></path><path id="MJX-1-TEX-N-7A" d="M42 263Q44 270 48 345T53 423V431H393Q399 425 399 415Q399 403 398 402L381 378Q364 355 331 309T265 220L134 41L182 40H206Q254 40 283 46T331 77Q352 105 359 185L361 201Q361 202 381 202H401V196Q401 195 393 103T384 6V0H209L34 1L31 3Q28 8 28 17Q28 30 29 31T160 210T294 394H236Q169 393 152 388Q127 382 113 367Q89 344 82 264V255H42V263Z"></path><path id="MJX-1-TEX-N-72" d="M36 46H50Q89 46 97 60V68Q97 77 97 91T98 122T98 161T98 203Q98 234 98 269T98 328L97 351Q94 370 83 376T38 385H20V408Q20 431 22 431L32 432Q42 433 60 434T96 436Q112 437 131 438T160 441T171 442H174V373Q213 441 271 441H277Q322 441 343 419T364 373Q364 352 351 337T313 322Q288 322 276 338T263 372Q263 381 265 388T270 400T273 405Q271 407 250 401Q234 393 226 386Q179 341 179 207V154Q179 141 179 127T179 101T180 81T180 66V61Q181 59 183 57T188 54T193 51T200 49T207 48T216 47T225 47T235 46T245 46H276V0H267Q249 3 140 3Q37 3 28 0H20V46H36Z"></path><path id="MJX-1-TEX-N-79" d="M69 -66Q91 -66 104 -80T118 -116Q118 -134 109 -145T91 -160Q84 -163 97 -166Q104 -168 111 -168Q131 -168 148 -159T175 -138T197 -106T213 -75T225 -43L242 0L170 183Q150 233 125 297Q101 358 96 368T80 381Q79 382 78 382Q66 385 34 385H19V431H26L46 430Q65 430 88 429T122 428Q129 428 142 428T171 429T200 430T224 430L233 431H241V385H232Q183 385 185 366L286 112Q286 113 332 227L376 341V350Q376 365 366 373T348 383T334 385H331V431H337H344Q351 431 361 431T382 430T405 429T422 429Q477 429 503 431H508V385H497Q441 380 422 345Q420 343 378 235T289 9T227 -131Q180 -204 113 -204Q69 -204 44 -177T19 -116Q19 -89 35 -78T69 -66Z"></path><path id="MJX-1-TEX-N-70" d="M36 -148H50Q89 -148 97 -134V-126Q97 -119 97 -107T97 -77T98 -38T98 6T98 55T98 106Q98 140 98 177T98 243T98 296T97 335T97 351Q94 370 83 376T38 385H20V408Q20 431 22 431L32 432Q42 433 61 434T98 436Q115 437 135 438T165 441T176 442H179V416L180 390L188 397Q247 441 326 441Q407 441 464 377T522 216Q522 115 457 52T310 -11Q242 -11 190 33L182 40V-45V-101Q182 -128 184 -134T195 -145Q216 -148 244 -148H260V-194H252L228 -193Q205 -192 178 -192T140 -191Q37 -191 28 -194H20V-148H36ZM424 218Q424 292 390 347T305 402Q234 402 182 337V98Q222 26 294 26Q345 26 384 80T424 218Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mtext"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use><use data-c="6C" xlink:href="#MJX-1-TEX-N-6C" transform="translate(389,0)"></use><use data-c="65" xlink:href="#MJX-1-TEX-N-65" transform="translate(667,0)"></use><use data-c="6E" xlink:href="#MJX-1-TEX-N-6E" transform="translate(1111,0)"></use><use data-c="67" xlink:href="#MJX-1-TEX-N-67" transform="translate(1667,0)"></use><use data-c="74" xlink:href="#MJX-1-TEX-N-74" transform="translate(2167,0)"></use><use data-c="68" xlink:href="#MJX-1-TEX-N-68" transform="translate(2556,0)"></use><use data-c="20" xlink:href="#MJX-1-TEX-N-20" transform="translate(3112,0)"></use><use data-c="6F" xlink:href="#MJX-1-TEX-N-6F" transform="translate(3362,0)"></use><use data-c="66" xlink:href="#MJX-1-TEX-N-66" transform="translate(3862,0)"></use><use data-c="20" xlink:href="#MJX-1-TEX-N-20" transform="translate(4168,0)"></use><use data-c="64" xlink:href="#MJX-1-TEX-N-64" transform="translate(4418,0)"></use><use data-c="61" xlink:href="#MJX-1-TEX-N-61" transform="translate(4974,0)"></use><use data-c="74" xlink:href="#MJX-1-TEX-N-74" transform="translate(5474,0)"></use><use data-c="61" xlink:href="#MJX-1-TEX-N-61" transform="translate(5863,0)"></use><use data-c="29" xlink:href="#MJX-1-TEX-N-29" transform="translate(6363,0)"></use></g><g data-mml-node="mo" transform="translate(6974.2,0)"><use data-c="2217" xlink:href="#MJX-1-TEX-N-2217"></use></g><g data-mml-node="mtext" transform="translate(7696.4,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use><use data-c="73" xlink:href="#MJX-1-TEX-N-73" transform="translate(389,0)"></use><use data-c="69" xlink:href="#MJX-1-TEX-N-69" transform="translate(783,0)"></use><use data-c="7A" xlink:href="#MJX-1-TEX-N-7A" transform="translate(1061,0)"></use><use data-c="65" xlink:href="#MJX-1-TEX-N-65" transform="translate(1505,0)"></use><use data-c="20" xlink:href="#MJX-1-TEX-N-20" transform="translate(1949,0)"></use><use data-c="6F" xlink:href="#MJX-1-TEX-N-6F" transform="translate(2199,0)"></use><use data-c="66" xlink:href="#MJX-1-TEX-N-66" transform="translate(2699,0)"></use><use data-c="20" xlink:href="#MJX-1-TEX-N-20" transform="translate(3005,0)"></use><use data-c="73" xlink:href="#MJX-1-TEX-N-73" transform="translate(3255,0)"></use><use data-c="74" xlink:href="#MJX-1-TEX-N-74" transform="translate(3649,0)"></use><use data-c="6F" xlink:href="#MJX-1-TEX-N-6F" transform="translate(4038,0)"></use><use data-c="72" xlink:href="#MJX-1-TEX-N-72" transform="translate(4538,0)"></use><use data-c="65" xlink:href="#MJX-1-TEX-N-65" transform="translate(4930,0)"></use><use data-c="64" xlink:href="#MJX-1-TEX-N-64" transform="translate(5374,0)"></use><use data-c="20" xlink:href="#MJX-1-TEX-N-20" transform="translate(5930,0)"></use><use data-c="64" xlink:href="#MJX-1-TEX-N-64" transform="translate(6180,0)"></use><use data-c="61" xlink:href="#MJX-1-TEX-N-61" transform="translate(6736,0)"></use><use data-c="74" xlink:href="#MJX-1-TEX-N-74" transform="translate(7236,0)"></use><use data-c="61" xlink:href="#MJX-1-TEX-N-61" transform="translate(7625,0)"></use><use data-c="20" xlink:href="#MJX-1-TEX-N-20" transform="translate(8125,0)"></use><use data-c="74" xlink:href="#MJX-1-TEX-N-74" transform="translate(8375,0)"></use><use data-c="79" xlink:href="#MJX-1-TEX-N-79" transform="translate(8764,0)"></use><use data-c="70" xlink:href="#MJX-1-TEX-N-70" transform="translate(9292,0)"></use><use data-c="65" xlink:href="#MJX-1-TEX-N-65" transform="translate(9848,0)"></use><use data-c="29" xlink:href="#MJX-1-TEX-N-29" transform="translate(10292,0)"></use></g></g></g></svg></mjx-container></div>
<p>To get the first part is simple using <code>std::vector</code> methods. For the second part,
we can take advantage of the <code>sizeof()</code> function and pass in the data type stored
in our vector.</p>
<div class="task-callout callout"><p>In <code>InitializeGL</code>, pass a triangle’s worth of data into your VBO.</p></div>
<h2 id="vertex-array-objects"><a href="#vertex-array-objects">Vertex Array Objects</a></h2>
<p>Next, we will tell OpenGL the structure of our data using something called a Vertex Array Object or VAO for short.</p>
<h3 id="vertex-attributes"><a href="#vertex-attributes">Vertex Attributes</a></h3>
<p>At the moment, the only data we have cared about is the position of each vertex.
But as a matter of fact, each vertex can have many more attributes than just its
position. Consider colors, texture coordinates, or, as you saw in the previous lab,
normals. These can also be unique to each vertex and it is our job to tell OpenGL what
attributes we care about.</p>
<p>When adding multiple attributes, they should appear in the same order and be repeated
per vertex in our data. Consider again figure which shows a data layout
containing positions and colors interleaved:</p>
<figure id="figure-1" class="image-wrapper"><div class="image-grid" style="--target-width:95%"><img src="/labs/lab9/VBO_VAO_Overview.png" alt="TODO"/></div><figcaption><strong>Figure 1: </strong>Visualization of VBOs and VAOs</figcaption></figure>
<div class="task-callout callout"><p>Add colors of your choosing as RGB values to each vertex and integrate them
into your previous triangle data vector in <code>InitializeGL</code>.</p></div>
<details><summary>Does your <code>std::vector</code> look familiar?</summary><p>It should! This is the same format of data we worked with in the last lab!
Without knowing it, you were actually creating VBO/VAO ready data with position
and normal attributes! Keep that in mind when working on the project!</p></details>
<h3 id="creating-a-vao"><a href="#creating-a-vao">Creating a VAO</a></h3>
<p>Now let’s tell OpenGL that we have this extra attribute by making a VAO!
The function to do this is:</p>
<div class="success-callout callout"><p style="text-align:center"><blockquote>
<p><a href="https://registry.khronos.org/OpenGL-Refpages/es3.1/html/glGenVertexArrays.xhtml"><strong>void glGenVertexArrays(GLsizei n, GLuint *arrays);</strong></a></p>
</blockquote></p><p><strong><code>n</code> :</strong> This indicates the number of vertex array objects to create.</p><p><strong><code>arrays</code> :</strong> This is the pointer this function will fill in with an id
for the generated array. Similarly to glGenBuffers, you can also fill in an array
or segment of continuous memory with pointers to vertex array objects.</p></div>
<div class="task-callout callout"><p>In <code>InitializeGL</code>, generate a single VAO and store its id in <code>m_vao</code>.</p></div>
<h3 id="binding-a-vao"><a href="#binding-a-vao">Binding a VAO</a></h3>
<p>Next to actually use this VAO, we need to bind it to the state.
The function to do this is:</p>
<div class="success-callout callout"><p style="text-align:center"><blockquote>
<p><a href="https://registry.khronos.org/OpenGL-Refpages/es3.1/html/glBindVertexArray.xhtml"><strong>void glBindVertexArray(GLuint array);</strong></a></p>
</blockquote></p><p><strong><code>n</code> :</strong> This is the id of the VAO we wish to bind</p></div>
<div class="task-callout callout"><p>In <code>InitializeGL</code>, bind your VAO.</p></div>
<h3 id="utilizing-a-vao"><a href="#utilizing-a-vao">Utilizing a VAO</a></h3>
<p>Now that the VAO is bound, we can actually use it to let OpenGL know the structure
of our VBO.</p>
<p>For <em><strong>each</strong></em> attribute, we need to do two things:</p>
<ol>
<li>Let OpenGL know we are identifying an attribute and which one</li>
<li>Specify the location and layout of the attribute in the VBO data.</li>
</ol>
<p>For the first part, we call on the following function:</p>
<div class="success-callout callout"><p style="text-align:center"><blockquote>
<p><a href="https://registry.khronos.org/OpenGL-Refpages/es3.1/html/glEnableVertexAttribArray.xhtml"><strong>void glEnableVertexAttribArray(GLuint index);</strong></a></p>
</blockquote></p><p><strong><code>index</code> :</strong> This indicates the index of the attribute we are identifying. By index, this
refers not to an index into our data array, but rather, if we were to list our attributes
as follows:</p><p>[position, color, UV]</p><p>Then the position would correlate with index 0, color with 1, and UV with 2.</p></div>
<p>For the second part, we use a more complex function:</p>
<div class="success-callout callout"><p style="text-align:center"><blockquote>
<p><a href="https://registry.khronos.org/OpenGL-Refpages/es3.1/html/glVertexAttribPointer.xhtml"><strong>void glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean
normalized, GLsizei stride, const void* pointer);</strong></a></p>
</blockquote></p><p><strong><code>index</code> :</strong> This is the same index as used in glEnableVertexAttribArray above.</p><p><strong><code>size</code> :</strong> This indicates the length of one vertex’s instance of this attribute,
not the size in bytes. For a position of 3 floats, this would simply be 3. For
an attribute that has 5 ints, this would be 5.</p><p><strong><code>type</code> :</strong> This indicates the type of variable used for each component in the
attribute. For floats, this would be GL_FLOAT.</p><p><strong><code>normalized</code> :</strong> This is a bit complicated to do with types, but for now use GL_FALSE.</p><p><strong><code>stride</code> :</strong> This indicates the size in bytes between two vertices.
That is, the distance between the x coordinate of the position of the first vertex
and the x coordinate of the second vertex in bytes would be this value</p><p><strong><code>pointer</code> :</strong> This is a pointer to the first vertex’s instance of the attribute
in the array of data. However, this more so refers to the offset into the array in
which you will find this attribute. That is in the figure 1
(figure showing position,color,uv), the offset of the color attribute is
3*sizeof(GLfloat). But to cast this into a void*, we need to use:
<code>reinterpret_cast&lt;void*&gt;(offset value)</code></p><figure id="figure-4" class="image-wrapper"><div class="image-grid" style="--target-width:95%"><img src="/labs/lab9/Stride_Offset_White_Background.png" alt="TODO"/></div><figcaption><strong>Figure 4: </strong>Visualization of Vertex Attribute layouts</figcaption></figure></div>
<blockquote>
<p>Note: These two functions will assume they apply to whichever VBO is currently bound,
so be careful of your state when using them. As a matter of fact, you can store separate
attributes of the same object in different VBOs and link them together in a single VAO as
in figure 5 below!</p>
</blockquote>
<figure id="figure-5" class="image-wrapper"><div class="image-grid" style="--target-width:80%"><img src="/labs/lab9/VAOMultiple.png" alt="TODO"/></div><figcaption><strong>Figure 5: </strong>VAOs w/ Single and Multiple VBOs</figcaption></figure>
<div class="task-callout callout"><p>Add the two attributes of position and color to your VAO in <code>InitializeGL</code>.</p></div>
<h2 id="unbinding-objects"><a href="#unbinding-objects">Unbinding Objects</a></h2>
<p>In section 1.2, we discussed common approaches to handling the OpenGL state machine.
Here, we will implement these ideas by keeping a common default state set. When we
started, VBO and VAO ids 0 were bound, which means no VBO or VAO was bound. Let’s
return to that starting condition before we exit the <code>initializeGL</code> function.</p>
<div class="task-callout callout"><p>Unbind your VBO and VAO at the end of <code>InitializeGL</code>.</p></div>
<h2 id="drawing-in-opengl"><a href="#drawing-in-opengl">Drawing in OpenGL</a></h2>
<h3 id="drawing-overview"><a href="#drawing-overview">Drawing Overview</a></h3>
<p>Great! Now you are ready to draw the triangle you have worked so hard to create.
To do this, these are the general steps you will want to follow each frame.</p>
<ol>
<li>Clear the screen using <code>glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</code></li>
<li>For each shader you want to use:<!-- -->
<ol>
<li>Bind the shader using <code>glUseProgram(GLuint program);</code></li>
<li>For each VAO you want to draw with the current shader:<!-- -->
<ol>
<li>Bind the VAO</li>
<li>Draw using <code>glDrawArrays(GLenum mode, GLint first, GLsizei count);</code></li>
<li>Unbind the VAO</li>
</ol>
</li>
<li>Unbind the shader using <code>glUseProgram(0);</code></li>
</ol>
</li>
</ol>
<blockquote>
<p>Note: Notice how all operations including a specific shader and VAO are surrounded by a Bind and Unbind call!</p>
</blockquote>
<p>For this, you will only be responsible for steps 1 and 2.2.1 through 2.2.3.
While steps 2 and 2.2 can run as loops for each shader and for each VAO, oftentimes such as this one you
will only work with a single shader program and in this case, a single VAO.
As such, no loops will need to be present in this section of the lab.</p>
<div class="task-callout callout"><p>In <code>PaintGL</code>, before <code>glUseProgram</code>, clear the screen.</p></div>
<div class="task-callout callout"><p>In <code>PaintGL</code>, after <code>glUseProgram</code>, bind our VAO.</p></div>
<h3 id="the-gldrawarrays-call"><a href="#the-gldrawarrays-call">The glDrawArrays Call</a></h3>
<p>Let&#x27;s take a look at how we actually <em>draw</em> our VBOs.</p>
<div class="success-callout callout"><p style="text-align:center"><blockquote>
<p><a href="https://registry.khronos.org/OpenGL-Refpages/es3.1/html/glDrawArrays.xhtml"><strong>void glDrawArrays(GLenum mode, GLint first, GLsizei count);</strong></a></p>
</blockquote></p><p><strong><code>mode</code> :</strong> This indicates the type of primitive to render, for our case, use GL_TRIANGLES.</p><p><strong><code>first</code> :</strong> This indicates the starting index for OpenGL to look in our VBO, and will most usually be 0.</p><p><strong><code>count</code> :</strong> This indicates how many vertices to draw.</p></div>
<div class="task-callout callout"><p>In the middle of <code>PaintGL</code>, draw our triangle.</p></div>
<div class="task-callout callout"><p>After drawing the triangle in <code>PaintGL</code>, return to default state by unbinding our VAO.</p></div>
<h2 id="memory-management"><a href="#memory-management">Memory Management</a></h2>
<p>So far, by calling <code>glGenBuffers</code> and <code>glGenVertexArrays</code>, we have <em>allocated</em> space
to store our data and objects. Unlike smart pointers however, this memory is <strong>not</strong>
automatically freed when it goes out of scope. To do this ourselves, we must call on the
various <code>glDelete</code> functions at our disposal.</p>
<p>For now we will use two, <a href="https://registry.khronos.org/OpenGL-Refpages/es3.1/html/glDeleteBuffers.xhtml">glDeleteBuffers</a>
which applies to VBOs, and <a href="https://registry.khronos.org/OpenGL-Refpages/es3.1/html/glDeleteVertexArrays.xhtml">glDeleteVertexArrays</a>
which applies to VAOs.</p>
<p>In general, the glDelete calls are described as follows.</p>
<div class="success-callout callout"><p style="text-align:center"><blockquote>
<p><strong>void glDelete_____(GLsizei n, const GLuint *object);</strong></p>
</blockquote></p><p><strong><code>n</code> :</strong> This indicates how many of the object to delete.</p><p><strong><code>object</code> :</strong> This is a pointer to the object being deleted. Or as we could create multiple within an array or
continuous segment of memory, the pointer to the beginning of this memory can also be passed in.</p></div>
<div class="task-callout callout"><p>In <code>finish</code>, free your VBO and VAO memory.</p></div>
<hr class="footer-hr"/><p class="footer-p">Please let us know if you find any mistakes, inconsistencies, or confusing language in this or any other CS 1230 document by filling out our <a href="https://forms.gle/ZYY519pzSvu8YaZK6" target="_blank">anonymous feedback form</a>.</p><style>
mjx-container[jax=&quot;SVG&quot;] {
  direction: ltr;
}

mjx-container[jax=&quot;SVG&quot;] &gt; svg {
  overflow: visible;
  min-height: 1px;
  min-width: 1px;
}

mjx-container[jax=&quot;SVG&quot;] &gt; svg a {
  fill: blue;
  stroke: blue;
}

mjx-container[jax=&quot;SVG&quot;][display=&quot;true&quot;] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax=&quot;SVG&quot;][display=&quot;true&quot;][width=&quot;full&quot;] {
  display: flex;
}

mjx-container[jax=&quot;SVG&quot;][justify=&quot;left&quot;] {
  text-align: left;
}

mjx-container[jax=&quot;SVG&quot;][justify=&quot;right&quot;] {
  text-align: right;
}

g[data-mml-node=&quot;merror&quot;] &gt; g {
  fill: red;
  stroke: red;
}

g[data-mml-node=&quot;merror&quot;] &gt; rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node=&quot;mtable&quot;] &gt; line[data-line], svg[data-table] &gt; g &gt; line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node=&quot;mtable&quot;] &gt; rect[data-frame], svg[data-table] &gt; g &gt; rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node=&quot;mtable&quot;] &gt; .mjx-dashed, svg[data-table] &gt; g &gt; .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node=&quot;mtable&quot;] &gt; .mjx-dotted, svg[data-table] &gt; g &gt; .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node=&quot;mtable&quot;] &gt; g &gt; svg {
  overflow: visible;
}

[jax=&quot;SVG&quot;] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax=&quot;SVG&quot;] mjx-tool &gt; mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool &gt; mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node=&quot;maction&quot;][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

mjx-container[jax=&quot;SVG&quot;] path[data-c], mjx-container[jax=&quot;SVG&quot;] use[data-c] {
  stroke-width: 3;
}
</style></main></div>
        </div>
      <script id="vite-plugin-ssr_pageContext" type="application/json">{"pageContext":{"_pageId":"/pages/labs/lab9"}}</script><script type="module" src="/assets/entry-client-routing.886ad6bf.js" async></script><link rel="modulepreload" as="script" type="text/javascript" href="/assets/pages/labs/lab9.page.ef2c07c1.js"><link rel="modulepreload" as="script" type="text/javascript" href="/assets/chunk-903e764a.js"><link rel="modulepreload" as="script" type="text/javascript" href="/assets/chunk-30f40460.js"><link rel="modulepreload" as="script" type="text/javascript" href="/assets/chunk-b2e2a089.js"><link rel="modulepreload" as="script" type="text/javascript" href="/assets/renderer/_default.page.client.7254b951.js"><link rel="modulepreload" as="script" type="text/javascript" href="/assets/entry-client-routing.886ad6bf.js"><link rel="modulepreload" as="script" type="text/javascript" href="/assets/chunk-042e0972.js"></body>
    </html>