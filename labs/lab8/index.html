<!DOCTYPE html>
    <html lang="en">
      <head><link rel="stylesheet" type="text/css" href="/assets/index.9059ccae.css">
        <meta charset="UTF-8">
        <title>Lab 8 | CSCI 1230</title>
        <meta name="description" content="We teach computer graphics!">
        <meta name="keywords" content="Computer Science, Computer Graphics, CS 1230,CSCI 1230, Brown University, Providence">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
      </head>
      <body>
        <div id="root">
          <nav id="nav-bar"><div id="nav-bar-inner"><a id="logo" class="no-select" href="/" aria-label="home" style="--duration:450ms"><div id="logo-box-1"></div><div id="logo-box-2"></div><div id="logo-box-3"></div><div id="logo-box-4"></div><div id="logo-box-5"></div><div id="logo-box-6"></div></a><div id="nav-items"><a href="/" class="nav-item">Home</a><a href="/docs" class="nav-item">Docs</a><a href="/lectures" class="nav-item">Lectures</a><a href="/labs" class="nav-item">Labs</a><a href="/projects" class="nav-item">Projects</a></div></div></nav><div id="page" class=""><nav class="toc"><ol class="toc-level toc-level-1"><li class="toc-item toc-item-h1"><a class="toc-link toc-link-h1" href="#lab-8-trimeshes">Lab 8: Trimeshes</a><ol class="toc-level toc-level-2"><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#intro">Intro</a><ol class="toc-level toc-level-3"><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#objectives">Objectives</a></li></ol></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#objects-as-trimeshes">Objects as Trimeshes</a><ol class="toc-level toc-level-3"><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#level-of-detail-tessellation-level">Level-of-Detail (Tessellation Level)</a></li></ol></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#trimesh-representation">Trimesh Representation</a><ol class="toc-level toc-level-3"><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#a-single-triangle">A Single Triangle</a><ol class="toc-level toc-level-4"><li class="toc-item toc-item-h4"><a class="toc-link toc-link-h4" href="#per-face-normals">Per-Face Normals</a></li><li class="toc-item toc-item-h4"><a class="toc-link toc-link-h4" href="#per-vertex-normals">Per-Vertex Normals</a></li><li class="toc-item toc-item-h4"><a class="toc-link toc-link-h4" href="#winding-order">Winding Order</a></li></ol></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#multiple-triangles">Multiple Triangles</a></li></ol></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#getting-started">Getting Started</a><ol class="toc-level toc-level-3"><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#stencil-code">Stencil Code</a><ol class="toc-level toc-level-4"><li class="toc-item toc-item-h4"><a class="toc-link toc-link-h4" href="#the-code">The Code</a></li><li class="toc-item toc-item-h4"><a class="toc-link toc-link-h4" href="#the-gui">The GUI</a></li></ol></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#draw-a-triangle">Draw a Triangle</a></li></ol></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#cube">Cube</a><ol class="toc-level toc-level-3"><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#tile">Tile</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#cube-face">Cube Face</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#full-cube">Full Cube</a></li></ol></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#sphere">Sphere</a><ol class="toc-level toc-level-3"><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#spherical-coordinates">Spherical Coordinates</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#wedge">Wedge</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#full-sphere">Full Sphere</a></li></ol></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#end">End</a><ol class="toc-level toc-level-3"><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#food-for-thought">Food For Thought</a></li></ol></li></ol></li></ol></nav><main>
<h1 id="lab-8-trimeshes"><a href="#lab-8-trimeshes">Lab 8: Trimeshes</a></h1>
<ul>
<li><a href="todo">Github Classroom</a></li>
<li><a href="https://forms.gle/ZYY519pzSvu8YaZK6">Anonymous feedback form</a></li>
</ul>
<div class="warning-callout callout"><p><strong>This is one of the more time-consuming labs.</strong> We intend each lab to be completed within 2 hours, so if you reach the 2 hour mark and have only completed <code>Cube</code> and part of <code>Sphere</code>, please let us know!</p><p>We will get you checked off, but please keep in mind that for the Realtime 1 Project, you will have to have implemented the following shapes: <code>Cube</code>, <code>Sphere</code>, <code>Cylinder</code>, and <code>Cone</code>.</p></div>
<h2 id="intro"><a href="#intro">Intro</a></h2>
<p>One of the fundamental applications of computer graphics is to display 3D scenes. The catch, however, is that screens can only display 2D images. Therefore, we need to convert 3D objects into to something that can be viewed in 2D. A common method, which we will use in this lab, is to compose objects using triangles, then project those triangles to the screen.</p>
<details><summary>Why use triangles?</summary><p>Triangles are the only polygon that both have area and are guaranteed to lie on a single plane. This avoids a lot of issues, including making it easy to project them onto a 2D screen.</p><p>For historical and practical reasons, graphics hardware is optimized to render triangles very efficiently (graphics cards have dedicated circuits for rendering triangles).</p></details>
<p>In this lab, you will be breaking up 3D objects into a lot of triangles that, when put together, look as much like the desired 3D shape as possible. Curved surfaces can be better approximated using more triangles, but keep in mind that the more triangles we draw, the more triangles we compute!</p>
<h3 id="objectives"><a href="#objectives">Objectives</a></h3>
<p>By the end of this lab, you will:</p>
<ol>
<li>Learn to use triangle meshes to approximate an object&#x27;s surface.</li>
<li>Implement Cube and Sphere meshes with different levels of approximation</li>
</ol>
<div class="warning-callout callout"><p>You will need the code you write in this lab for your Realtime Projects!</p></div>
<h2 id="objects-as-trimeshes"><a href="#objects-as-trimeshes">Objects as Trimeshes</a></h2>
<p>We can represent any <strong>surface</strong> as a triangle mesh. Conveniently, most objects in the world are defined by a surface. These objects are usually a closed surface bounding a volume, like a Cube, Cone, Cylinder, or Sphere.</p>
<p>A collection of triangles that form a mesh is called a <strong>triangle mesh</strong>, or <strong>trimesh</strong> for short. The process of turning a shape or surface into a triangle mesh is called <strong>tessellation</strong>.</p>
<figure id="figure-1" class="image-wrapper"><div class="image-grid" style="--target-width:100%"><img src="/labs/lab8/trimeshExamples.jpg" alt="trimesh examples"/></div><figcaption><strong>Figure 1: </strong>Trimesh Object Examples</figcaption></figure>
<details><summary>Can everything be a mesh?</summary><p>Actually, some things cannot be easily represented as a trimesh. For example, you don&#x27;t typically think about fog as a surface, so it doesn&#x27;t make sense to represent it as a trimesh. There are other ways to represent objects like fog, such as volumetric rendering. If you&#x27;re interested, you can read more about volumetric rendering <a href="https://en.wikipedia.org/wiki/Volume_rendering">here</a>.</p></details>
<h3 id="level-of-detail-tessellation-level"><a href="#level-of-detail-tessellation-level">Level-of-Detail (Tessellation Level)</a></h3>
<p>Recall from the Ray projects that you represented 3D shapes as implicit equations. This theoretically allows for infinite surface resolution (up to floating point limits). On the other hand, trimeshes are approximations. The more triangles used to represent a surface, the more realistic the rendering, but the more computation is required. The number of triangles used, and thus the level-of-detail of the 3D shape, is called the <strong>tessellation level</strong>.</p>
<figure id="figure-2" class="image-wrapper"><div class="image-grid" style="--target-width:100%"><img src="/labs/lab8/tesselationLevel.jpg" alt="increasing tessellation on human head"/></div><figcaption><strong>Figure 2: </strong>A Face with Increasing Tessellation Levels</figcaption></figure>
<h2 id="trimesh-representation"><a href="#trimesh-representation">Trimesh Representation</a></h2>
<p>Trimeshes are composed of triangles which are composed of vertex positions (for rendering the triangle) and normals (for lighting the triangle).</p>
<h3 id="a-single-triangle"><a href="#a-single-triangle">A Single Triangle</a></h3>
<p>As you can probably guess, we render a triangle from a triplet of vertex positions in an <code>std::vector&lt;float&gt; vertexPositions</code>. It&#x27;s important to note, in our case, the winding order of the vertices is <strong>counter-clockwise</strong>.</p>
<figure id="figure-3" class="image-wrapper"><div class="image-grid" style="--target-width:100%"><img src="/labs/lab8/vertexPositions.jpg" alt="Counter-clockwise Vertex Positions"/></div><figcaption><strong>Figure 3: </strong>Counter-clockwise Vertex Positions</figcaption></figure>
<h4 id="per-face-normals"><a href="#per-face-normals">Per-Face Normals</a></h4>
<p>If we want every point on the triangle to have the same normal, we can use per-face normals. Since we have 3 vertices, we can form two vectors to calculate the normal by taking the cross product of those two vectors.</p>
<figure id="figure-4" class="image-wrapper"><div class="image-grid" style="--target-width:100%"><img src="/labs/lab8/perFaceNormal.jpg" alt="per face normal"/></div><figcaption><strong>Figure 4: </strong>A Normal For A Triangle Face</figcaption></figure>
<h4 id="per-vertex-normals"><a href="#per-vertex-normals">Per-Vertex Normals</a></h4>
<p>What if we want every triangle vertex to have a different normal? Then we use per-vertex normals. An example of a situation where we would want per-vertex normals is for curved surfaces or the tip of a cone.</p>
<figure id="figure-5" class="image-wrapper"><div class="image-grid" style="--target-width:100%"><img src="/labs/lab8/spherePerVertex.jpg" alt="normals on a sphere"/></div><figcaption><strong>Figure 5: </strong>Sphere Per-Vertex Normals, as Highlighted in Red</figcaption></figure>
<figure id="figure-6" class="image-wrapper"><div class="image-grid" style="--target-width:100%"><img src="/labs/lab8/conePerVertex.jpg" alt="normals on a cone"/></div><figcaption><strong>Figure 6: </strong>Cone Per-Vertex Normals, as Highlighted in Red</figcaption></figure>
<p>For our purposes, we will be using per-vertex normals. As shown below, each triangle is represented by 6 numbers, including <em>x</em>, <em>y</em>, and <em>z</em> for vertex positions and <em>i</em>, <em>j</em> and <em>k</em> for normals in <code>std::vector&lt;float&gt; m_vertexData</code>. We use <code>m_vertexData</code> since it&#x27;s shorter than <code>m_vertexPositionsAndNormals</code>, but also because we might want to add other information per vertex such as vertex color later in the course. Again, the winding order of vertices and normals is <strong>counter-clockwise</strong>.</p>
<figure id="figure-7" class="image-wrapper"><div class="image-grid" style="--target-width:100%"><img src="/labs/lab8/m_vertexData.jpg" alt="normals on a cone"/></div><figcaption><strong>Figure 7: </strong>Visual representation of m_vertexData</figcaption></figure>
<h4 id="winding-order"><a href="#winding-order">Winding Order</a></h4>
<p>Why Do Normals And Winding Order Matter?</p>
<p>In this lab and in the Realtime projects, you need the correct winding order of positions and normals to properly render the objects. This is because of backface culling. Backface culling is a rendering technique that determines which side of the triangle is visible.</p>
<figure id="figure-8" class="image-wrapper"><div class="image-grid" style="--target-width:100%"><img src="/labs/lab8/backfaceCulling.gif" alt="back face culling"/></div><figcaption><strong>Figure 8: </strong>Backface Culling on a Triangle</figcaption></figure>
<p>You can read more about backface culling <a href="https://www.easytechjunkie.com/what-is-back-face-culling.htm">here</a>.</p>
<h3 id="multiple-triangles"><a href="#multiple-triangles">Multiple Triangles</a></h3>
<p>Recall that the tessellation level determines the number of triangles used in a trimesh. As shown below, to represent a collection of triangles, we just append the additional triangle information onto the back of the list. In our case, this list is still represented as <code>std::vector&lt;float&gt; m_vertexData</code>.</p>
<figure id="figure-9" class="image-wrapper"><div class="image-grid" style="--target-width:100%"><img src="/labs/lab8/m_vertexData2.jpg" alt="visualization of m_vertexData"/></div><figcaption><strong>Figure 9: </strong>Vertex Data of a Cube</figcaption></figure>
<div class="success-callout callout"><p><strong>Notice in Figure 7:</strong></p><ol>
<li><code>m_vertexData</code> interleaves vertex positions and normals for each point.</li>
<li><code>m_vertexData</code> can contain repeats since points of multiple triangles will be in the same place to form a mesh.</li>
</ol></div>
<details><summary> Hold on... surely we don&#x27;t need to have all those repeated vertices </summary><p>If the repeated vertex data looks inefficient to you, you might be interested in <a href="https://en.wikipedia.org/wiki/Triangle_strip">triangle strips</a>, <a href="https://en.wikipedia.org/wiki/Triangle_fan">triangle fans</a>, etc.</p></details>
<h2 id="getting-started"><a href="#getting-started">Getting Started</a></h2>
<p>To summarize:</p>
<ol>
<li>A shape can be represented as a variable number of triangles, depending on the level of detail</li>
<li>A collection of triangles can be represented as a list of positions and normals</li>
</ol>
<p>Now, all that remains is to make our own implementation. At a high level, we are going to take in a shape, a level of detail, and spit out the list of points representing a trimesh!</p>
<h3 id="stencil-code"><a href="#stencil-code">Stencil Code</a></h3>
<h4 id="the-code"><a href="#the-code">The Code</a></h4>
<p>Take a look at our stencil code. The only files you need to concern yourself with in this lab are <code>Triangle.h/cpp</code>, <code>Cube.h/cpp</code>, and <code>Sphere.h/cpp</code>, which are all located in the <code>shapes/</code> directory.</p>
<blockquote>
<p><em>There are two additional classes,</em> <code>Cylinder</code> <em>and</em> <code>Cone</code>. <em>You will implement those in the first Realtime project.</em></p>
</blockquote>
<p>Each shape has a member variable, <code>std::vector&lt;GLfloat&gt; m_vertexData</code>. You will be editing this list with the positions and normals for each shape. <strong>Note that <code>m_vertexData</code> alternates between vertex positions and normals!</strong></p>
<p>Each shape will also have an <code>int m_param1</code> and/or <code>int m_param2</code>. These correspond to the parameter sliders that you&#x27;ll see in the UI when you start up the program.</p>
<div class="success-callout callout"><p>For our purposes, <strong>each shape is centered at the origin and has a radius of 0.5. In other words, they lie in the range [-0.5, 0.5] on all axes.</strong></p><p>We use the following coordinate system: <em>x</em> points to the right, <em>y</em> points upwards, and <em>z</em> points out of the screen towards the viewer.
<img src="/labs/lab8/openglCoordSys.png" alt="3D coordinate system"/></p></div>
<h4 id="the-gui"><a href="#the-gui">The GUI</a></h4>
<p>When you first run the code, you&#x27;ll see a GUI pop up that looks like this:</p>
<figure id="figure-10" class="image-wrapper"><div class="image-grid" style="--target-width:100%"><img src="/labs/lab8/gui.png" alt="trimesh GUI"/></div><figcaption><strong>Figure 10: </strong>Trimeshes GUI</figcaption></figure>
<p>On the left side of the GUI, there are toggles to change the shape and sliders to change parameter 1 and parameter 2. The parameters control the level of detail of each shape. We&#x27;ll go into detail about what specifically the parameters do later in the handout.</p>
<p>On the right side of the GUI, you will eventually see the shapes generated from <code>m_vertexData</code>. You won&#x27;t see anything right now because <code>m_vertexData</code> is empty.</p>
<h3 id="draw-a-triangle"><a href="#draw-a-triangle">Draw a Triangle</a></h3>
<p>You will first draw a triangle.</p>
<div class="task-callout callout"><p>In <code>Triangle.cpp</code>, fill out the <code>setVertexData()</code> function. This function should update <code>m_vertexData</code> with positions and normals. Remember that the normals are unit vectors!</p><p>Use the following coordinate points:</p><ul>
<li><code>(-0.5, 0.5, 0.0)</code></li>
<li><code>(-0.5, -0.5, 0.0)</code></li>
<li><code>(0.5, -0.5, 0.0)</code></li>
</ul></div>
<p>Your triangle should look like this:</p>
<figure id="figure-11" class="image-wrapper"><div class="image-grid" style="--target-width:100%"><img src="/labs/lab8/triangle.png" alt="triangle"/></div><figcaption><strong>Figure 11: </strong>Triangle Expected Output</figcaption></figure>
<blockquote>
<p>Notice that if you spin the triangle around, it&#x27;ll disappear. This is backface culling!</p>
</blockquote>
<h2 id="cube"><a href="#cube">Cube</a></h2>
<p>Now that you know how to create a triangle, it&#x27;s time to render a Cube :)</p>
<div class="warning-callout callout"><p>There are multiple ways you can implement a Cube. If you find a way that&#x27;s better than how we outlined it below, feel free to implement it your way!</p></div>
<div class="success-callout callout"><ul>
<li>The Cube is centered at the origin and has a radius of 0.5. This means that it lies in the range [-0.5, 0.5] on all axes.</li>
<li>The Cube is also axis-aligned, meaning each face will be perpendicular to the axes!</li>
</ul></div>
<h3 id="tile"><a href="#tile">Tile</a></h3>
<p>To create our Cube, you&#x27;ll first create a plane comprised of two triangles as shown below.</p>
<div class="task-callout callout"><p>In <code>Cube.cpp</code>:</p><ol>
<li>Uncomment the <code>makeTile()</code> function call in <code>setVertexData()</code></li>
<li>Implement the <code>makeTile()</code> function. This function should update <code>m_vertexData</code> with a plane made of two triangles created from the input points. Use what you learned from making a Triangle to do this! You will use this function for the next task.<!-- -->
<ul>
<li><em><code>makeTile()</code> takes in four input points, but you may not need to use all four points!</em></li>
</ul>
</li>
</ol><blockquote>
<p>You may find the following glm functions helpful:</p>
<ul>
<li><code>glm::vec3 glm::normalize(glm::vec3 v);</code></li>
<li><code>glm::vec3 glm::cross(glm::vec3 v1, glm::vec3 v2);</code></li>
</ul>
</blockquote></div>
<p>Your tile should look like this:</p>
<figure id="figure-12" class="image-wrapper"><div class="image-grid" style="--target-width:100%"><img src="/labs/lab8/tile.png" alt="tile"/></div><figcaption><strong>Figure 12: </strong>Tile Expected Output</figcaption></figure>
<h3 id="cube-face"><a href="#cube-face">Cube Face</a></h3>
<p>Now, that you have your tile, you can create one face of the Cube with tessellation!</p>
<p>Notice how parameter 1 controls the number of tiles in each row and column:</p>
<figure id="figure-13" class="image-wrapper"><div class="image-grid" style="--target-width:100%"><img src="/labs/lab8/tileParams.png" alt="tile parameters"/></div><figcaption><strong>Figure 13: </strong>Cube Face Levels of Detail</figcaption></figure>
<div class="task-callout callout"><p>In <code>Cube.cpp</code></p><ol>
<li>Comment out the <code>makeTile()</code> function call in <code>setVertexData()</code> and uncomment the <code>makeFace()</code> function call.</li>
<li>Complete the <code>makeFace()</code> function using the <code>makeTile()</code> function you wrote in the previous task. <code>m_param1</code> contains the parameter 1 value.<!-- -->
<ul>
<li><em>Note that when we generate a face of the Cube, it will be perpendicular to each axis.</em></li>
</ul>
</li>
</ol></div>
<p>Your face should look like this:</p>
<figure id="figure-14" class="image-wrapper"><div class="image-grid" style="--target-width:100%"><img src="/labs/lab8/faceTessellation.gif" alt="cube face tessellation"/></div><figcaption><strong>Figure 14: </strong>Cube Face Expected Output</figcaption></figure>
<h3 id="full-cube"><a href="#full-cube">Full Cube</a></h3>
<p>We now have one side of our Cube!</p>
<div class="task-callout callout"><p>Implement all 6 sides of your Cube using the <code>makeFace()</code> function you implemented in the previous task.</p><blockquote>
<p>Remember that the Cube has a radius of 0.5 and lies in the bounds [-0.5, 0.5] on all axes.
<em>It may be helpful to draw a diagram of the Cube to figure out the positions of all its corners!</em></p>
</blockquote></div>
<p>Your Cube should now look like this:</p>
<figure id="figure-15" class="image-wrapper"><div class="image-grid" style="--target-width:100%"><img src="/labs/lab8/cube.gif" alt="A Cube Tessellating"/></div><figcaption><strong>Figure 15: </strong>Full Cube Expected Output</figcaption></figure>
<h2 id="sphere"><a href="#sphere">Sphere</a></h2>
<p>Yay! Congratulations on making your Cube! Now it&#x27;s time to make a Sphere.</p>
<p>As shown below, we can think of the Sphere like an orange. Oranges are made up of wedges and each wedge is made up segments. We can build an orange (aka a sphere) by procedurally generating a collection of orange wedges.</p>
<figure id="figure-16" class="image-wrapper"><div class="image-grid" style="--target-width:100%"><img src="/labs/lab8/orange.jpg" alt="orange anatomy"/></div><figcaption><strong>Figure 16: </strong>Orange Segments create Orange Wedges that creates an Orange</figcaption></figure>
<p>The orange analogy will be helpful in understanding the Sphere parameters. As shown below, the shape parameters for Sphere are slightly different than Cube. Parameter 1 controls the number of &#x27;orange segments&#x27; (like latitude), and parameter 2 controls the number of &#x27;orange wedges&#x27; (like longitude).</p>
<details><summary>Longitude and Latitude</summary><p><img src="/labs/lab8/latitude-longitude.gif" alt="lat_long"/></p></details>
<figure id="figure-17" class="image-wrapper"><div class="image-grid" style="--target-width:100%"><img src="/labs/lab8/sphereParams.jpg" alt="sphere parameters"/></div><figcaption><strong>Figure 17: </strong>Sphere Levels of Detail</figcaption></figure>
<div class="success-callout callout"><p>Like Cube, the Sphere is centered at the origin and has a radius of 0.5, so it lies in the bounds [-0.5, 0.5] on all axes.</p></div>
<h3 id="spherical-coordinates"><a href="#spherical-coordinates">Spherical Coordinates</a></h3>
<p>We can represent this &#x27;orange wedge and segment&#x27; idea using spherical coordinates. In terms of spherical coordinates, parameter 1 controls 𝜙 and parameter 2 controls 𝜃.</p>
<details><summary>Refresher: The Spherical Coordinate System</summary><p>Remember polar coordinates (<em>r</em>, 𝜃) from high school geometry? Spherical coordinates (<em>r</em>, 𝜃, 𝜙) are like polar coordinates but in 3D! The spherical coordinate system specifies a 3D point in space using (<em>r</em>, 𝜃, 𝜙). for more details, read this <a href="https://en.wikipedia.org/wiki/Spherical_coordinate_system">Wikipedia article on the Spherical Coordinate System</a> :)</p></details>
<figure id="figure-18" class="image-wrapper"><div class="image-grid" style="--target-width:100%"><img src="/labs/lab8/sphericalCoordSys.jpg" alt="spherical coordinate system"/></div><figcaption><strong>Figure 18: </strong>The Spherical Coordinate System</figcaption></figure>
<h3 id="wedge"><a href="#wedge">Wedge</a></h3>
<p>Similar to making a Cube, the first step in creating a sphere is to create a tile that can be replicated across the sphere depending on the level of detail.</p>
<div class="task-callout callout"><p>In <code>Sphere.cpp</code>, implement the <code>makeTile()</code> function. This function should update <code>m_vertexData</code>.</p><blockquote>
<p>You may find the following functions helpful:</p>
<ul>
<li><code>glm::vec3 glm::normalize(glm::vec3 v);</code></li>
</ul>
</blockquote><blockquote>
<p><strong>Note:</strong> The normals are calculated differently from those in Cube. Refer to the diagram below for what your normals should look like. <figure id="figure-19" class="image-wrapper"><div class="image-grid" style="--target-width:100%"><img src="/labs/lab8/sphereNormals.jpg" alt="sphere normals"/></div><figcaption><strong>Figure 19: </strong>Sphere Normals Emanating From the Origin</figcaption></figure></p>
</blockquote></div>
<div class="task-callout callout"><ol>
<li>Uncomment the <code>makeWedge()</code> function call in <code>setVertexData()</code></li>
<li>Implement the <code>makeWedge()</code> function using the <code>makeTile()</code> function you wrote.</li>
</ol><p>Remember that we are making a wedge, so you need to pay attention to <code>m_param1</code> and 𝜙. Refer to the top half of <a href="#figure-17">Figure 17</a> for how <code>m_param1</code> affects the level of detail. Also note that everything is in radians!</p><blockquote>
<p>Hint: You may find the following functions helpful:</p>
<ul>
<li><code>float glm::radians(float x)</code></li>
<li><code>float glm::sin(float x)</code></li>
<li><code>float glm::cos(float x)</code></li>
</ul>
</blockquote><blockquote>
<p>Hint: You may also find these equations useful:</p>
<ul>
<li><code>x = r * sin(𝜙) * cos(𝜃)</code></li>
<li><code>y = r * cos(𝜙)</code></li>
<li><code>z = r * sin(𝜙) * sin(𝜃)</code></li>
</ul>
</blockquote></div>
<p>Your wedge should look like this:</p>
<figure id="figure-20" class="image-wrapper"><div class="image-grid" style="--target-width:100%"><img src="/labs/lab8/wedge.gif" alt="wedge tessellating"/></div><figcaption><strong>Figure 20: </strong>A Wedge of a Sphere Tessellating</figcaption></figure>
<h3 id="full-sphere"><a href="#full-sphere">Full Sphere</a></h3>
<p>We can now use our <code>makeWedge()</code> function to generate a full sphere!</p>
<div class="task-callout callout"><ol>
<li>Comment out the <code>makeWedge()</code> function call in <code>setVertexData()</code> and uncomment the <code>makeOrange()</code> function call.</li>
<li>Implement the <code>makeOrange()</code> function using <code>makeWedge()</code>.</li>
</ol><p>Remember that we are making multiple wedges (aka a Sphere), so you need to pay attention to <code>m_param2</code> and 𝜃. Refer to the bottom half of <a href="#figure-17">Figure 17</a> for how <code>m_param2</code> affects the level of detail.</p></div>
<p>Your sphere should look like this:</p>
<figure id="figure-21" class="image-wrapper"><div class="image-grid" style="--target-width:100%"><img src="/labs/lab8/sphere.gif" alt="Completed Sphere"/></div><figcaption><strong>Figure 21: </strong>A Completed Sphere</figcaption></figure>
<h2 id="end"><a href="#end">End</a></h2>
<p>Now you&#x27;re ready to show your work to a TA and get checked off! Congrats on finishing the Trimeshes lab :)</p>
<h3 id="food-for-thought"><a href="#food-for-thought">Food For Thought</a></h3>
<p>Next lab, you&#x27;ll delve into the graphics pipeline by using OpenGL to render triangle meshes. OpenGL uses VBOs (vertex buffer objects) which store a list of vertices similar to <code>m_vertexData</code> in this lab. You&#x27;ll learn more about this next week, but this is notably why <code>m_vertexData</code> interleaves position and normal data for each vertex. Good luck!</p>
<hr class="footer-hr"/><p class="footer-p">Please let us know if you find any mistakes, inconsistencies, or confusing language in this or any other CS 1230 document by filling out our <a href="https://forms.gle/ZYY519pzSvu8YaZK6" target="_blank">anonymous feedback form</a>.</p></main></div>
        </div>
      <script id="vite-plugin-ssr_pageContext" type="application/json">{"pageContext":{"_pageId":"/pages/labs/lab8"}}</script><script type="module" src="/assets/entry-client-routing.57f4ea7f.js" async></script><link rel="modulepreload" as="script" type="text/javascript" href="/assets/pages/labs/lab8.page.0997242e.js"><link rel="modulepreload" as="script" type="text/javascript" href="/assets/chunk-47a93a9e.js"><link rel="modulepreload" as="script" type="text/javascript" href="/assets/chunk-e84bc917.js"><link rel="modulepreload" as="script" type="text/javascript" href="/assets/chunk-9ad3b198.js"><link rel="modulepreload" as="script" type="text/javascript" href="/assets/renderer/_default.page.client.bf9d5346.js"><link rel="modulepreload" as="script" type="text/javascript" href="/assets/entry-client-routing.57f4ea7f.js"><link rel="modulepreload" as="script" type="text/javascript" href="/assets/chunk-fffd8fac.js"></body>
    </html>