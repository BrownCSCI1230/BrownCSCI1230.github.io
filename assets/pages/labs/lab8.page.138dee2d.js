import{j as e}from"../../chunk-6ef03c1b.js";import{I as t}from"../../chunk-f0aa7aed.js";import{M as i}from"../../chunk-b9ea0eaf.js";const c={title:"Lab 8"};function o(r){const s=Object.assign({nav:"nav",ol:"ol",li:"li",a:"a",main:"main",h1:"h1",p:"p",h2:"h2",h3:"h3",div:"div",strong:"strong",code:"code",h4:"h4",ul:"ul",img:"img",em:"em",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td"},r.components);return e.exports.jsxs(e.exports.Fragment,{children:[e.exports.jsx(s.nav,{className:"toc",children:e.exports.jsx(s.ol,{className:"toc-level toc-level-1",children:e.exports.jsxs(s.li,{className:"toc-item toc-item-h1",children:[e.exports.jsx(s.a,{className:"toc-link toc-link-h1",href:"#lab-8-trimeshes",children:"Lab 8: Trimeshes"}),e.exports.jsxs(s.ol,{className:"toc-level toc-level-2",children:[e.exports.jsxs(s.li,{className:"toc-item toc-item-h2",children:[e.exports.jsx(s.a,{className:"toc-link toc-link-h2",href:"#intro",children:"Intro"}),e.exports.jsx(s.ol,{className:"toc-level toc-level-3",children:e.exports.jsx(s.li,{className:"toc-item toc-item-h3",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h3",href:"#objectives",children:"Objectives"})})})]}),e.exports.jsxs(s.li,{className:"toc-item toc-item-h2",children:[e.exports.jsx(s.a,{className:"toc-link toc-link-h2",href:"#objects-as-meshes",children:"Objects as Meshes"}),e.exports.jsx(s.ol,{className:"toc-level toc-level-3",children:e.exports.jsx(s.li,{className:"toc-item toc-item-h3",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h3",href:"#level-of-detail-tessellation-level",children:"Level-of-Detail (Tessellation Level)"})})})]}),e.exports.jsxs(s.li,{className:"toc-item toc-item-h2",children:[e.exports.jsx(s.a,{className:"toc-link toc-link-h2",href:"#trimesh-representation",children:"Trimesh Representation"}),e.exports.jsxs(s.ol,{className:"toc-level toc-level-3",children:[e.exports.jsxs(s.li,{className:"toc-item toc-item-h3",children:[e.exports.jsx(s.a,{className:"toc-link toc-link-h3",href:"#a-single-triangle",children:"A Single Triangle"}),e.exports.jsxs(s.ol,{className:"toc-level toc-level-4",children:[e.exports.jsx(s.li,{className:"toc-item toc-item-h4",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h4",href:"#per-face-normals",children:"Per-Face Normals"})}),e.exports.jsx(s.li,{className:"toc-item toc-item-h4",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h4",href:"#per-vertex-normals",children:"Per-Vertex Normals"})}),e.exports.jsx(s.li,{className:"toc-item toc-item-h4",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h4",href:"#winding-order",children:"Winding Order"})})]})]}),e.exports.jsx(s.li,{className:"toc-item toc-item-h3",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h3",href:"#multiple-triangles",children:"Multiple Triangles"})})]})]}),e.exports.jsxs(s.li,{className:"toc-item toc-item-h2",children:[e.exports.jsx(s.a,{className:"toc-link toc-link-h2",href:"#start-coding",children:"Start Coding"}),e.exports.jsxs(s.ol,{className:"toc-level toc-level-3",children:[e.exports.jsx(s.li,{className:"toc-item toc-item-h3",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h3",href:"#stencil-code",children:"Stencil Code"})}),e.exports.jsx(s.li,{className:"toc-item toc-item-h3",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h3",href:"#draw-a-triangle",children:"Draw a Triangle"})})]})]}),e.exports.jsxs(s.li,{className:"toc-item toc-item-h2",children:[e.exports.jsx(s.a,{className:"toc-link toc-link-h2",href:"#cube",children:"Cube"}),e.exports.jsxs(s.ol,{className:"toc-level toc-level-3",children:[e.exports.jsx(s.li,{className:"toc-item toc-item-h3",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h3",href:"#tile",children:"Tile"})}),e.exports.jsx(s.li,{className:"toc-item toc-item-h3",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h3",href:"#cube-face",children:"Cube Face"})}),e.exports.jsx(s.li,{className:"toc-item toc-item-h3",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h3",href:"#full-cube",children:"Full Cube"})})]})]}),e.exports.jsxs(s.li,{className:"toc-item toc-item-h2",children:[e.exports.jsx(s.a,{className:"toc-link toc-link-h2",href:"#sphere",children:"Sphere"}),e.exports.jsxs(s.ol,{className:"toc-level toc-level-3",children:[e.exports.jsx(s.li,{className:"toc-item toc-item-h3",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h3",href:"#spherical-coordinates",children:"Spherical Coordinates"})}),e.exports.jsx(s.li,{className:"toc-item toc-item-h3",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h3",href:"#wedge",children:"Wedge"})}),e.exports.jsx(s.li,{className:"toc-item toc-item-h3",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h3",href:"#full-sphere",children:"Full Sphere"})})]})]}),e.exports.jsxs(s.li,{className:"toc-item toc-item-h2",children:[e.exports.jsx(s.a,{className:"toc-link toc-link-h2",href:"#end",children:"End"}),e.exports.jsx(s.ol,{className:"toc-level toc-level-3",children:e.exports.jsx(s.li,{className:"toc-item toc-item-h3",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h3",href:"#food-for-thought",children:"Food For Thought"})})})]})]})]})})}),e.exports.jsxs(s.main,{children:[`
`,e.exports.jsx(s.h1,{id:"lab-8-trimeshes",children:e.exports.jsx(s.a,{href:"#lab-8-trimeshes",children:"Lab 8: Trimeshes"})}),`
`,e.exports.jsx(s.p,{children:e.exports.jsx(s.a,{href:"https://google.com",children:"GitHub Classroom assignment"})}),`
`,e.exports.jsx(s.h2,{id:"intro",children:e.exports.jsx(s.a,{href:"#intro",children:"Intro"})}),`
`,e.exports.jsx(s.p,{children:"One of the fundamental applications of computer graphics is to display 3D scenes. The catch, however, is that screens can only display 2D images. Therefore, we need to convert 3D objects into to something that can be viewed in 2D. A common method, which we will use in this lab, is to compose objects using triangles, then project those triangles to the screen."}),`
`,e.exports.jsxs("details",{children:[e.exports.jsx("summary",{children:"Why use triangles?"}),e.exports.jsx(s.p,{children:"Triangles are the only polygon that both have area and are guaranteed to lie on a single plane. This avoids a lot of issues, including making it easy to project them onto a 2D screen."}),e.exports.jsx(s.p,{children:"For historical and practical reasons, triangles are optimized to be rendered really quickly on computer hardware. Graphics cards often have dedicated circuits optimized for this function."})]}),`
`,e.exports.jsx(s.p,{children:"In this lab, you will be breaking up 3D objects into a lot of triangles that, when put together, look as much like the desired 3D shape as possible. Curved surfaces can be better approximated using more triangles, but keep in mind that the more triangles we draw the more triangles we compute!"}),`
`,e.exports.jsx(s.h3,{id:"objectives",children:e.exports.jsx(s.a,{href:"#objectives",children:"Objectives"})}),`
`,e.exports.jsx(s.p,{children:"By the end of this lab, you will:"}),`
`,e.exports.jsxs(s.ol,{children:[`
`,e.exports.jsx(s.li,{children:"Learn to use trimeshes as a way to approximately represent an object's surface."}),`
`,e.exports.jsx(s.li,{children:"Implement a Cube and a Sphere with changing tesselation."}),`
`]}),`
`,e.exports.jsx(s.div,{className:"warning-callout callout",children:e.exports.jsx(s.p,{children:"You will need the code you write in this lab for your Realtime Projects!"})}),`
`,e.exports.jsx(s.h2,{id:"objects-as-meshes",children:e.exports.jsx(s.a,{href:"#objects-as-meshes",children:"Objects as Meshes"})}),`
`,e.exports.jsxs(s.p,{children:["We can represent any ",e.exports.jsx(s.strong,{children:"surface"})," as a triangle mesh. Conveniently, most objects in the world are defined by a surface. These objects are usually a closed surface bounding a volume, like a Cube, Cone, Cylinder or Sphere."]}),`
`,e.exports.jsxs(s.p,{children:["A collection of triangles that form a mesh is called a ",e.exports.jsx(s.strong,{children:"triangle mesh"}),", or ",e.exports.jsx(s.strong,{children:"trimesh"})," for short. The process of turning a shape or surface into a triangle mesh is called ",e.exports.jsx(s.strong,{children:"tesselating"}),"."]}),`
`,e.exports.jsx(s.p,{children:"![gif of exploding trimesh][url]"}),`
`,e.exports.jsxs("details",{children:[e.exports.jsx("summary",{children:"Can everything be a mesh?"}),e.exports.jsxs(s.p,{children:["Actually, some things cannot be easily represented as a trimesh. For example, you don't typically think about fog as a surface, so it doesn't make sense to represent it as a trimesh. There are other ways to represent objects like fog, such as volumetric rendering. If you're interested, you can read more about volumetric rendering ",e.exports.jsx(s.a,{href:"https://en.wikipedia.org/wiki/Volume_rendering",children:"here"}),"."]})]}),`
`,e.exports.jsx(s.h3,{id:"level-of-detail-tessellation-level",children:e.exports.jsx(s.a,{href:"#level-of-detail-tessellation-level",children:"Level-of-Detail (Tessellation Level)"})}),`
`,e.exports.jsxs(s.p,{children:["Recall from the Ray projects that you represented the 3D shapes as implicit equations. This technically allows for infinite resolution (up to floating point limits). On the other hand, trimeshes are approximations. The more triangles used to represent a surface, the more realistic the rendering, but the more computation is required. The number of triangles used, and thus the level-of-detail of the 3D shape, is called the ",e.exports.jsx(s.strong,{children:"tessellation level"}),"."]}),`
`,e.exports.jsx(t,{images:[{src:"https://i.stack.imgur.com/uT6do.jpg",alt:"TODO"}],figNumber:1,figCaption:"A Face With 3 Different Tessellation Levels"}),`
`,e.exports.jsx(s.h2,{id:"trimesh-representation",children:e.exports.jsx(s.a,{href:"#trimesh-representation",children:"Trimesh Representation"})}),`
`,e.exports.jsx(s.p,{children:"Trimeshes are composed of triangles (duh) which are then composed of vertex positions (for rendering the triangle) and normals (for lighting the triangle)."}),`
`,e.exports.jsx(s.h3,{id:"a-single-triangle",children:e.exports.jsx(s.a,{href:"#a-single-triangle",children:"A Single Triangle"})}),`
`,e.exports.jsxs(s.p,{children:["As you can probably guess, we render a triangle from a triplet of vertex positions in ",e.exports.jsx(s.code,{children:"std::vector<float> vertexPositions"}),". It's important to note, in our case, the winding order of the vertices is ",e.exports.jsx(s.strong,{children:"counter-clockwise"}),"."]}),`
`,e.exports.jsx(s.p,{children:"![vertex positions and triangles][url]"}),`
`,e.exports.jsx(s.h4,{id:"per-face-normals",children:e.exports.jsx(s.a,{href:"#per-face-normals",children:"Per-Face Normals"})}),`
`,e.exports.jsx(s.p,{children:"If we want every point on the triangle to have the same normal, we can use per-face normals. Since we have 3 vertices, we can form two vectors to calculate the normal by taking the cross product of those two vectors."}),`
`,e.exports.jsx(t,{images:[{src:"https://i.stack.imgur.com/WzZ1l.jpg",alt:"TODO"}],figNumber:3,figCaption:"A Normal For A Triangle Face"}),`
`,e.exports.jsx(s.h4,{id:"per-vertex-normals",children:e.exports.jsx(s.a,{href:"#per-vertex-normals",children:"Per-Vertex Normals"})}),`
`,e.exports.jsx(s.p,{children:"What if we want every triangle vertex to have a different normal? Then we use per-vertex normals. An example of a situation where we would want per-vertex normals is for curved surfaces."}),`
`,e.exports.jsx(t,{images:[{src:"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcR8POJPG4fGELGDbSflJFVyeboNzoPWS-IEjA&usqp=CAU",alt:"TODO"}],figNumber:4,figCaption:"Curved Surface Normals"}),`
`,e.exports.jsx(t,{images:[{src:"/labs/lab8/amog-us-among-us.gif",alt:"TODO"}],figNumber:5,figCaption:"Cone With Normals At The Tips"}),`
`,e.exports.jsxs(s.p,{children:["For our purposes, we will be using per-vertex normals. Each triangle is represented by 6 numbers, including x, y, and z for vertex positions and x, y and z for normals in ",e.exports.jsx(s.code,{children:"std::vector<float> vertexData"}),". We use ",e.exports.jsx(s.code,{children:"vertexData"})," since it's shorter than ",e.exports.jsx(s.code,{children:"vertexPositionsAndNormals"}),", but also because we might want to add other information per vertex such as vertex color later in the course. Again, the winding order of vertices and normals is ",e.exports.jsx(s.strong,{children:"counter-clockwise"}),"."]}),`
`,e.exports.jsx(s.h4,{id:"winding-order",children:e.exports.jsx(s.a,{href:"#winding-order",children:"Winding Order"})}),`
`,e.exports.jsx(s.p,{children:"Why Do Normals And Winding Order Matter?"}),`
`,e.exports.jsx(s.p,{children:"In this lab and in the Realtime projects, you need the correct winding order of positions and normals to properly render the objects. This is because of backface culling. Backface culling is a rendering technique that determines which side of the triangle is visible."}),`
`,e.exports.jsx(t,{images:[{src:"/labs/lab8/back-face-culling.png",alt:"TODO"}],figNumber:6,figCaption:"The Order of Points Matters When Rendering"}),`
`,e.exports.jsxs(s.p,{children:["You can read more about backface culling ",e.exports.jsx(s.a,{href:"https://www.easytechjunkie.com/what-is-back-face-culling.htm",children:"here"}),"."]}),`
`,e.exports.jsx(s.h3,{id:"multiple-triangles",children:e.exports.jsx(s.a,{href:"#multiple-triangles",children:"Multiple Triangles"})}),`
`,e.exports.jsxs(s.p,{children:["If you combine multiple triangles together, you'll end up with a ",e.exports.jsx(s.strong,{children:"trimesh"}),"! Recall that the tessellation level determines the number of triangles used in the trimesh."]}),`
`,e.exports.jsxs(s.p,{children:["How do we represent a collection of triangles? Well, we've already seen a possible solution: just append the additional triangle information onto the back of the list. In our case, this list is still represented as ",e.exports.jsx(s.code,{children:"std::vector<float> vertexData"}),"."]}),`
`,e.exports.jsx(s.div,{className:"warning-callout callout",children:e.exports.jsxs(s.p,{children:[e.exports.jsx(s.code,{children:"m_vertexData"})," interleaves vertex positions and normals for each point."]})}),`
`,e.exports.jsx(t,{images:[{src:"/labs/lab8/triangle_example.png",alt:"TODO"}],figNumber:7,figCaption:"Vertex Data"}),`
`,e.exports.jsx(s.div,{className:"warning-callout callout",children:e.exports.jsxs(s.p,{children:["Notice that ",e.exports.jsx(s.code,{children:"vertexData"})," can contain repeats since points of multiple triangles will be the same place to form a mesh."]})}),`
`,e.exports.jsxs("details",{children:[e.exports.jsx("summary",{children:" Hold on... surely we don't need to have all those repeated vertices "}),e.exports.jsxs(s.p,{children:["If the repeated vertex data looks inefficient to you, you might be interested in ",e.exports.jsx(s.a,{href:"https://en.wikipedia.org/wiki/Triangle_strip",children:"triangle strips"}),", ",e.exports.jsx(s.a,{href:"https://en.wikipedia.org/wiki/Triangle_fan",children:"triangle fans"}),", etc."]})]}),`
`,e.exports.jsx(s.h2,{id:"start-coding",children:e.exports.jsx(s.a,{href:"#start-coding",children:"Start Coding"})}),`
`,e.exports.jsx(s.p,{children:"Well, now we know the most important things:"}),`
`,e.exports.jsxs(s.ol,{children:[`
`,e.exports.jsx(s.li,{children:"A shape can be represented as a variable number of triangles, depending on the level of detail"}),`
`,e.exports.jsx(s.li,{children:"A collection of triangles can be represented as a list of positions and normals"}),`
`]}),`
`,e.exports.jsx(s.p,{children:"Now, all that remains is to make our own implementation. At a high level, we are going to take in a shape, a level of detail, and spit out the list of points representing a trimesh!"}),`
`,e.exports.jsx(s.h3,{id:"stencil-code",children:e.exports.jsx(s.a,{href:"#stencil-code",children:"Stencil Code"})}),`
`,e.exports.jsxs(s.p,{children:["Take a look at our stencil code. The only files you need to concern yourself with are the files in the shapes folder. For this lab, you'll only be working with ",e.exports.jsx(s.code,{children:"Triangle"}),", ",e.exports.jsx(s.code,{children:"Cube"}),", and ",e.exports.jsx(s.code,{children:"Sphere"}),". You will need to implement ",e.exports.jsx(s.code,{children:"Cylinder"})," and ",e.exports.jsx(s.code,{children:"Cone"})," for Realtime 1. Check the comments within the code for how exactly to edit each shape."]}),`
`,e.exports.jsx(s.p,{children:"You'll notice on the left side of the UI, there are toggles to change the shape and sliders to change parameter 1 and parameter 2. The parameters control the tessellation level of each shape. We'll go into detail about what specifically the parameters do later in the handout."}),`
`,e.exports.jsxs(s.p,{children:["For now, notice that each shape inherits ",e.exports.jsx(s.code,{children:"std::vector<float> m_vertexData"})," from ",e.exports.jsx(s.code,{children:"OpenGLShape"}),"."]}),`
`,e.exports.jsx(t,{images:[{src:"/labs/lab8/m_vertex_data.png",alt:"TODO"}],figNumber:7,figCaption:"m_vertexData for a Cube"}),`
`,e.exports.jsxs(s.p,{children:["On the right side of the UI you will be rendering the shapes generated from ",e.exports.jsx(s.code,{children:"m_vertexData"}),". You won't see anything right now because ",e.exports.jsx(s.code,{children:"m_vertexData"})," is empty."]}),`
`,e.exports.jsx(s.h3,{id:"draw-a-triangle",children:e.exports.jsx(s.a,{href:"#draw-a-triangle",children:"Draw a Triangle"})}),`
`,e.exports.jsx(s.p,{children:"You will first draw a triangle."}),`
`,e.exports.jsxs(s.div,{className:"task-callout callout",children:[e.exports.jsxs(s.p,{children:["In the Triangle class, fill out the ",e.exports.jsx(s.code,{children:"setVertexData()"})," function stub. Use the following coordinate points:"]}),e.exports.jsxs(s.ul,{children:[`
`,e.exports.jsx(s.li,{children:e.exports.jsx(s.code,{children:"(-0.5, -0.5, 0)"})}),`
`,e.exports.jsx(s.li,{children:e.exports.jsx(s.code,{children:"(0.5, -0.5, 0)"})}),`
`,e.exports.jsx(s.li,{children:e.exports.jsx(s.code,{children:"(-0.5, 0.5, 0)"})}),`
`]})]}),`
`,e.exports.jsx(s.p,{children:"Don\u2019t forget the normals!"}),`
`,e.exports.jsx(s.p,{children:"Your triangle should look like this:"}),`
`,e.exports.jsx(t,{images:[{src:"/labs/lab8/amog-us-among-us.gif",alt:"TODO"}],figNumber:10,figCaption:"A Triangle Rendered"}),`
`,e.exports.jsx(s.p,{children:"Notice that if you spin the triangle around, it'll disappear. This is backface culling!"}),`
`,e.exports.jsx(s.h2,{id:"cube",children:e.exports.jsx(s.a,{href:"#cube",children:"Cube"})}),`
`,e.exports.jsx(s.p,{children:"Now that you know how to create a triangle, it's time to render a Cube :)"}),`
`,e.exports.jsx(s.div,{className:"warning-callout callout",children:e.exports.jsx(s.p,{children:"Each shape is centered at the origin and has a radius of 0.5. This means that they lie in the range [-0.5, 0.5] on all axes."})}),`
`,e.exports.jsx(s.h3,{id:"tile",children:e.exports.jsx(s.a,{href:"#tile",children:"Tile"})}),`
`,e.exports.jsx(s.p,{children:"To create our Cube, you'll first create a plane comprised of two triangles as shown below."}),`
`,e.exports.jsx(s.div,{className:"task-callout callout",children:e.exports.jsxs(s.p,{children:["In the Cube class, implement the ",e.exports.jsx(s.code,{children:"makeTile()"})," function stub. Don\u2019t forget the normals!"]})}),`
`,e.exports.jsx(s.div,{className:"task-callout callout",children:e.exports.jsxs(s.p,{children:["Uncomment the ",e.exports.jsx(s.code,{children:"makeTile()"})," function call in ",e.exports.jsx(s.code,{children:"setVertexData()"}),". Note that you'll use this function for the next task."]})}),`
`,e.exports.jsx(s.p,{children:"Your tile should look like this:"}),`
`,e.exports.jsx(s.p,{children:"TODO: Insert image when Testing"}),`
`,e.exports.jsx(t,{images:[{src:"/labs/lab8/amog-us-among-us.gif",alt:"TODO"}],figNumber:10,figCaption:"A Tile"}),`
`,e.exports.jsx(s.h3,{id:"cube-face",children:e.exports.jsx(s.a,{href:"#cube-face",children:"Cube Face"})}),`
`,e.exports.jsx(s.p,{children:"Now, that you have your tile, you can create one face of the Cube with tessellation!"}),`
`,e.exports.jsxs(s.p,{children:["When you run ",e.exports.jsx(s.code,{children:"Lab 8"}),", the first slider on the left side of the screen (shape parameter 1) should change the tessellation of the Cube as shown:"]}),`
`,e.exports.jsx(t,{images:[{src:"/labs/lab8/cube_parameters.jpeg",alt:"TODO"}],figNumber:8,figCaption:"Changing The Tesselation Parameter On A Cube"}),`
`,e.exports.jsx(s.div,{className:"task-callout callout",children:e.exports.jsxs(s.p,{children:["Comment out the ",e.exports.jsx(s.code,{children:"makeTile()"})," function call in ",e.exports.jsx(s.code,{children:"setVertexData()"})," and uncomment the ",e.exports.jsx(s.code,{children:"makeFace()"})," function call."]})}),`
`,e.exports.jsxs(s.p,{children:["Now, you can use the ",e.exports.jsx(s.code,{children:"makeTile()"})," function you wrote in the previous task in ",e.exports.jsx(s.code,{children:"makeFace()"})," to render the positive z face of the Cube."]}),`
`,e.exports.jsxs("details",{children:[e.exports.jsx("summary",{children:"Reminder about our coordinate system "}),e.exports.jsx(s.p,{children:"As shown below, the positive X axis points towards the right of the screen, the positive Y axis points towards the top of the screen, and the positive Z axis points out of the screen towards the viewer."}),e.exports.jsxs(s.p,{children:[e.exports.jsx(s.img,{src:"/labs/lab8/coor_sys.png",alt:"Cooridnate-System"}),`
This coordinate system is used by our support code, and is based off of what is used by OpenGL, which you will learn about later.`]})]}),`
`,e.exports.jsx(s.div,{className:"task-callout callout",children:e.exports.jsxs(s.p,{children:["In the ",e.exports.jsx(s.code,{children:"Cube"})," class, fill out the ",e.exports.jsx(s.code,{children:"makeFace()"})," function stub."]})}),`
`,e.exports.jsx(s.p,{children:"You should end up with something that looks like this:"}),`
`,e.exports.jsx(s.p,{children:"TODO: Insert Image when Testing"}),`
`,e.exports.jsx(t,{images:[{src:"/labs/lab8/amog-us-among-us.gif",alt:"TODO"}],figNumber:11,figCaption:"A Face Of A Cube With Different Tesselations"}),`
`,e.exports.jsx(s.h3,{id:"full-cube",children:e.exports.jsx(s.a,{href:"#full-cube",children:"Full Cube"})}),`
`,e.exports.jsx(s.p,{children:"We now have one side of our Cube!"}),`
`,e.exports.jsxs(s.div,{className:"task-callout callout",children:[e.exports.jsxs(s.p,{children:["Implement all 6 sides of your Cube using the ",e.exports.jsx(s.code,{children:"makeFace()"})," function you filled out."]}),e.exports.jsxs(s.ul,{children:[`
`,e.exports.jsx(s.li,{children:"Remember that the Cube has a radius of 0.5 and lies in the bounds [-0.5, 0.5] on all axes."}),`
`,e.exports.jsx(s.li,{children:"It may be helpful to draw a diagram of the Cube to figure out the positions of all its corners!"}),`
`]})]}),`
`,e.exports.jsx(s.p,{children:"Your Cube should now look like this:"}),`
`,e.exports.jsx(s.p,{children:"TODO: Insert Image when Testing"}),`
`,e.exports.jsx(t,{images:[{src:"/labs/lab8/amog-us-among-us.gif",alt:"TODO"}],figNumber:12,figCaption:"A Full Cube"}),`
`,e.exports.jsx(s.h2,{id:"sphere",children:e.exports.jsx(s.a,{href:"#sphere",children:"Sphere"})}),`
`,e.exports.jsx(s.p,{children:"Yay! Congratulations on making your Cube! Now it's time to make a Sphere."}),`
`,e.exports.jsx(s.p,{children:"We can think of a sphere like an orange. Oranges are made up of wedges and each wedge is made up segments. We can build an orange (aka a sphere) by procedurally generating a collection of orange wedges."}),`
`,e.exports.jsxs(s.p,{children:["The shape parameters for our ",e.exports.jsx(s.code,{children:"Sphere"})," are slightly different than ",e.exports.jsx(s.code,{children:"Cube"}),". The first parameter controls the number of 'segments' (like latitude), and the second parameter controls the number of 'wedges' (like longitude). You can look at and ",e.exports.jsx(s.a,{href:"#figure-13",children:"Figure 13"})," and ",e.exports.jsx(s.a,{href:"#figure-14",children:"Figure 14"})," below to see how the tesselation of the ",e.exports.jsx(s.code,{children:"Sphere"})," changes when the parameters change."]}),`
`,e.exports.jsxs("details",{children:[e.exports.jsx("summary",{children:"Longitude and Latitude"}),e.exports.jsx(s.p,{children:e.exports.jsx(s.img,{src:"/labs/lab8/latitude-longitude.gif",alt:"lat_long"})})]}),`
`,e.exports.jsx(t,{images:[{src:"/labs/lab8/sphere-param1.png",alt:"sphere-param1"}],figNumber:13,figCaption:"Changing Parameter 1 On A Sphere"}),`
`,e.exports.jsx(t,{images:[{src:"/labs/lab8/sphere-param2.png",alt:"sphere-param2"}],figNumber:14,figCaption:"Changing Parameter 2 On A Sphere"}),`
`,e.exports.jsx(s.p,{children:"Like Cube, the Sphere is centered at the origin and has a radius of 0.5, so it lies in the bounds [-0.5, 0.5] on all axes."}),`
`,e.exports.jsx(s.h3,{id:"spherical-coordinates",children:e.exports.jsx(s.a,{href:"#spherical-coordinates",children:"Spherical Coordinates"})}),`
`,e.exports.jsx(s.p,{children:"We can represent this 'orange wedge and segment' idea using spherical coordinates. In terms of spherical coordinates, parameter 1 controls \u{1D719} and parameter 2 controls \u{1D703}."}),`
`,e.exports.jsxs("details",{children:[e.exports.jsx("summary",{children:"Refresher: The Spherical Coordinate System"}),e.exports.jsxs(s.p,{children:["Remember polar coordinates (",e.exports.jsx(s.em,{children:"r"}),", \u{1D703}) from high school geometry? Spherical coordinates (",e.exports.jsx(s.em,{children:"r"}),", \u{1D703}, \u{1D719}) are like polar coordinates but in 3D! The spherical coordinate system specifies a 3D point in space using (",e.exports.jsx(s.em,{children:"r"}),", \u{1D703}, \u{1D719}). for more details, read this ",e.exports.jsx(s.a,{href:"https://en.wikipedia.org/wiki/Spherical_coordinate_system",children:"Wikipedia article on the Spherical Coordinate System"})," :)"]})]}),`
`,e.exports.jsx(s.div,{className:"table-wrapper",children:e.exports.jsxs(s.table,{children:[e.exports.jsx(s.thead,{children:e.exports.jsxs(s.tr,{children:[e.exports.jsx(s.th,{align:"center",children:"Coordinate"}),e.exports.jsx(s.th,{align:"center",children:"Diagram"})]})}),e.exports.jsxs(s.tbody,{children:[e.exports.jsxs(s.tr,{children:[e.exports.jsxs(s.td,{align:"center",children:[e.exports.jsx(s.em,{children:"r"}),": the radial distance from the origin. For sphere, ",e.exports.jsx(s.code,{children:"r=0.5"})]}),e.exports.jsx(s.td,{align:"center",children:e.exports.jsx(s.img,{src:"/labs/lab8/amog-us-among-us.gif",alt:"radial"})})]}),e.exports.jsxs(s.tr,{children:[e.exports.jsx(s.td,{align:"center",children:"\u{1D703}: the polar angle. For sphere, this is in radians."}),e.exports.jsx(s.td,{align:"center",children:e.exports.jsx(s.img,{src:"/labs/lab8/amog-us-among-us.gif",alt:"polar"})})]}),e.exports.jsxs(s.tr,{children:[e.exports.jsx(s.td,{align:"center",children:"\u{1D719}: the azimuthal angle. For sphere, this is in radians."}),e.exports.jsx(s.td,{align:"center",children:e.exports.jsx(s.img,{src:"/labs/lab8/amog-us-among-us.gif",alt:"azimuthal"})})]})]})]})}),`
`,e.exports.jsx(s.h3,{id:"wedge",children:e.exports.jsx(s.a,{href:"#wedge",children:"Wedge"})}),`
`,e.exports.jsx(s.p,{children:"Similar to making a Cube, the first step in creating a sphere is to create a tile that can be replicated accross the sphere depening on the tesselation."}),`
`,e.exports.jsxs(s.div,{className:"task-callout callout",children:[e.exports.jsxs(s.p,{children:["Implement the ",e.exports.jsx(s.code,{children:"makeTile()"})," function stub in the ",e.exports.jsx(s.code,{children:"Sphere"})," Class."]}),e.exports.jsxs(s.p,{children:["This function should look very similar to the ",e.exports.jsx(s.code,{children:"makeTile()"})," function in the ",e.exports.jsx(s.code,{children:"Cube"})," class."]}),e.exports.jsxs(s.p,{children:["Note that the normals are calculated differently from those in Cube. Refer to ",e.exports.jsx(s.a,{href:"#figure-3",children:"Figure 15"})," for what your normals should look like."]})]}),`
`,e.exports.jsx(t,{images:[{src:"/labs/lab8/sphere-normals.png",alt:"sphere-normals"}],figNumber:15,figCaption:"The Normals On A Sphere"}),`
`,e.exports.jsxs(s.div,{className:"task-callout callout",children:[e.exports.jsxs(s.p,{children:["Implement the ",e.exports.jsx(s.code,{children:"makeWedge()"})," function stub in the ",e.exports.jsx(s.code,{children:"Sphere"})," Class."]}),e.exports.jsxs("ul",{children:[e.exports.jsxs("li",{children:["Use the ",e.exports.jsx(s.code,{children:"makeTile()"})," function from the previous task."]}),`
`,e.exports.jsx("li",{children:"Remember that we are making a wedge, so you need to pay attention to parameter 1 and \u{1D719}."}),`
`,e.exports.jsx("li",{children:"Remember that everything is in radians!"}),e.exports.jsxs("li",{children:[e.exports.jsx(s.p,{children:"You may find these function calls helpful:"}),e.exports.jsxs("ul",{children:[e.exports.jsx("li",{children:e.exports.jsx(s.code,{children:"glm::radians"})}),`
`,e.exports.jsx("li",{children:e.exports.jsx(s.code,{children:"glm::sin"})}),`
`,e.exports.jsx("li",{children:e.exports.jsx(s.code,{children:"glm::cos"})})]})]}),e.exports.jsxs("li",{children:[e.exports.jsx(s.p,{children:"You may also find these equations useful:"}),e.exports.jsxs("ul",{children:[e.exports.jsx("li",{children:e.exports.jsx(s.code,{children:"x = r * sin(\u{1D703}) * cos(\u{1D719})"})}),`
`,e.exports.jsx("li",{children:e.exports.jsx(s.code,{children:"y = r * sin(\u{1D703}) * sin(\u{1D719})"})}),`
`,e.exports.jsx("li",{children:e.exports.jsx(s.code,{children:"z = r * cos(\u{1D703})"})})]})]})]})]}),`
`,e.exports.jsx(s.p,{children:"Your wedge should look like this:"}),`
`," ",`
`,e.exports.jsx(t,{images:[{src:"/labs/lab8/amog-us-among-us.gif",alt:"TODO"}],figNumber:16,figCaption:"A Wedge Of A Sphere"}),`
`,e.exports.jsx(s.h3,{id:"full-sphere",children:e.exports.jsx(s.a,{href:"#full-sphere",children:"Full Sphere"})}),`
`,e.exports.jsxs(s.p,{children:["We can now use our ",e.exports.jsx(s.code,{children:"makeWedge()"})," function to generate a full sphere!"]}),`
`,e.exports.jsx(s.div,{className:"task-callout callout",children:e.exports.jsxs(s.p,{children:["Comment out the ",e.exports.jsx(s.code,{children:"makeWedge()"})," function call in ",e.exports.jsx(s.code,{children:"setVertexData()"})," and uncomment the ",e.exports.jsx(s.code,{children:"makeOrange()"})," function call."]})}),`
`,e.exports.jsx(s.div,{className:"task-callout callout",children:e.exports.jsxs(s.p,{children:["Implement the ",e.exports.jsx(s.code,{children:"makeOrange()"})," function stub in the ",e.exports.jsx(s.code,{children:"Sphere"})," Class."]})}),`
`,e.exports.jsxs("ul",{children:[e.exports.jsx("li",{children:"Remember that everything is in radians!"}),e.exports.jsx("li",{children:e.exports.jsx(s.p,{children:`Remember that we are making multiple wedges (aka a Sphere), so you need to pay attention to parameter 2
and \u{1D703}.`})})]}),`
`,e.exports.jsx(s.p,{children:"Your sphere should look like this:"}),`
`," ",`
`,e.exports.jsx(t,{images:[{src:"/labs/lab8/sphere.png",alt:"Completed-Sphere"}],figNumber:17,figCaption:"A Completed Sphere"}),`
`,e.exports.jsx(s.h2,{id:"end",children:e.exports.jsx(s.a,{href:"#end",children:"End"})}),`
`,e.exports.jsx(s.p,{children:"Now you're ready to show your work to a TA and get checked off! Congrats on finishing the Trimeshez lab."}),`
`,e.exports.jsx(s.h3,{id:"food-for-thought",children:e.exports.jsx(s.a,{href:"#food-for-thought",children:"Food For Thought"})}),`
`,e.exports.jsxs(s.p,{children:["Next Lab, you'll delve into the graphics pipeline by using OpenGL to render triangle meshes. OpenGL uses VBOs (vertex buffer objects) which store a list of vertices similar to ",e.exports.jsx(s.code,{children:"m_vertexData"})," in this lab. You'll learn more about this next week, but this is notably why ",e.exports.jsx(s.code,{children:"m_vertexData"})," interleaves position and normal data for each vertex. Good luck!"]}),`
`,e.exports.jsx(i,{})]})]})}function h(r={}){const{wrapper:s}=r.components||{};return s?e.exports.jsx(s,Object.assign({},r,{children:e.exports.jsx(o,r)})):o(r)}export{h as default,c as documentProps};
