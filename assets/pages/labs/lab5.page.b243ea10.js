import{j as e}from"../../chunk-47a93a9e.js";import{I as r}from"../../chunk-e84bc917.js";import{M as a}from"../../chunk-9ad3b198.js";const c={title:"Lab 5"};function n(t){const s=Object.assign({nav:"nav",ol:"ol",li:"li",a:"a",main:"main",h1:"h1",p:"p",h2:"h2",code:"code",strong:"strong",div:"div",h3:"h3",pre:"pre",span:"span",em:"em",h4:"h4",ul:"ul"},t.components);return e.exports.jsxs(e.exports.Fragment,{children:[e.exports.jsx(s.nav,{className:"toc",children:e.exports.jsx(s.ol,{className:"toc-level toc-level-1",children:e.exports.jsxs(s.li,{className:"toc-item toc-item-h1",children:[e.exports.jsx(s.a,{className:"toc-link toc-link-h1",href:"#lab-5-parsing",children:"Lab 5: Parsing"}),e.exports.jsxs(s.ol,{className:"toc-level toc-level-2",children:[e.exports.jsxs(s.li,{className:"toc-item toc-item-h2",children:[e.exports.jsx(s.a,{className:"toc-link toc-link-h2",href:"#introduction",children:"Introduction"}),e.exports.jsx(s.ol,{className:"toc-level toc-level-3",children:e.exports.jsx(s.li,{className:"toc-item toc-item-h3",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h3",href:"#scene-data-vs-render-data",children:"Scene Data vs. Render Data"})})})]}),e.exports.jsxs(s.li,{className:"toc-item toc-item-h2",children:[e.exports.jsx(s.a,{className:"toc-link toc-link-h2",href:"#scene-data",children:"Scene Data"}),e.exports.jsxs(s.ol,{className:"toc-level toc-level-3",children:[e.exports.jsx(s.li,{className:"toc-item toc-item-h3",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h3",href:"#global-data",children:"Global Data"})}),e.exports.jsx(s.li,{className:"toc-item toc-item-h3",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h3",href:"#lights",children:"Lights"})}),e.exports.jsx(s.li,{className:"toc-item toc-item-h3",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h3",href:"#camera",children:"Camera"})}),e.exports.jsx(s.li,{className:"toc-item toc-item-h3",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h3",href:"#primitives",children:"Primitives"})})]})]}),e.exports.jsxs(s.li,{className:"toc-item toc-item-h2",children:[e.exports.jsx(s.a,{className:"toc-link toc-link-h2",href:"#scene-graphs",children:"Scene Graphs"}),e.exports.jsxs(s.ol,{className:"toc-level toc-level-3",children:[e.exports.jsx(s.li,{className:"toc-item toc-item-h3",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h3",href:"#transformations",children:"Transformations"})}),e.exports.jsxs(s.li,{className:"toc-item toc-item-h3",children:[e.exports.jsx(s.a,{className:"toc-link toc-link-h3",href:"#transformation-graphs",children:"Transformation Graphs"}),e.exports.jsxs(s.ol,{className:"toc-level toc-level-4",children:[e.exports.jsx(s.li,{className:"toc-item toc-item-h4",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h4",href:"#order-of-transformations",children:"Order of Transformations"})}),e.exports.jsx(s.li,{className:"toc-item toc-item-h4",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h4",href:"#matrices",children:"Matrices"})}),e.exports.jsx(s.li,{className:"toc-item toc-item-h4",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h4",href:"#traversing-the-graph",children:"Traversing the Graph"})})]})]})]})]}),e.exports.jsxs(s.li,{className:"toc-item toc-item-h2",children:[e.exports.jsx(s.a,{className:"toc-link toc-link-h2",href:"#render-data",children:"Render Data"}),e.exports.jsxs(s.ol,{className:"toc-level toc-level-3",children:[e.exports.jsxs(s.li,{className:"toc-item toc-item-h3",children:[e.exports.jsx(s.a,{className:"toc-link toc-link-h3",href:"#implementing-sceneloaderparse",children:"Implementing SceneLoader::parse()"}),e.exports.jsxs(s.ol,{className:"toc-level toc-level-4",children:[e.exports.jsx(s.li,{className:"toc-item toc-item-h4",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h4",href:"#global-data-1",children:"Global data"})}),e.exports.jsx(s.li,{className:"toc-item toc-item-h4",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h4",href:"#camera-data",children:"Camera data"})}),e.exports.jsx(s.li,{className:"toc-item toc-item-h4",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h4",href:"#lights-1",children:"Lights"})}),e.exports.jsx(s.li,{className:"toc-item toc-item-h4",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h4",href:"#root-node",children:"Root Node"})}),e.exports.jsx(s.li,{className:"toc-item toc-item-h4",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h4",href:"#depth-first-search",children:"Depth-First Search"})})]})]}),e.exports.jsx(s.li,{className:"toc-item toc-item-h3",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h3",href:"#testing-scenes",children:"Testing scenes"})})]})]}),e.exports.jsx(s.li,{className:"toc-item toc-item-h2",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h2",href:"#optional-creating-your-own-3-d-scenes",children:"(Optional) Creating your own 3-d scenes"})}),e.exports.jsx(s.li,{className:"toc-item toc-item-h2",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h2",href:"#end",children:"End"})})]})]})})}),e.exports.jsxs(s.main,{children:[`
`,`
`,e.exports.jsx(s.h1,{id:"lab-5-parsing",children:e.exports.jsx(s.a,{href:"#lab-5-parsing",children:"Lab 5: Parsing"})}),`
`,e.exports.jsx(s.p,{children:e.exports.jsx(s.a,{href:"todo",children:"Github Classroom"})}),`
`,e.exports.jsx(s.h2,{id:"introduction",children:e.exports.jsx(s.a,{href:"#introduction",children:"Introduction"})}),`
`,e.exports.jsxs(s.p,{children:["In this lab, you will learn about the data structures used to represent 3d scenes. You will write code that turns an easy-to-build representation of scenes, ",e.exports.jsx(s.code,{children:"SceneData"}),", into ",e.exports.jsx(s.code,{children:"RenderData"}),", which is much easier to render an image from. You will learn how lights, cameras and primitives are represented, as well as how to read ",e.exports.jsx(s.strong,{children:"transformation graphs"})," so that every object has the correct final size and position in the scene."]}),`
`,e.exports.jsx(s.div,{className:"warning-callout callout",children:e.exports.jsxs(s.p,{children:["You will need the code you\u2019ve written in this lab for the upcoming assignments, including the ",e.exports.jsx(s.strong,{children:"Ray"})," and ",e.exports.jsx(s.strong,{children:"Realtime"})," projects!"]})}),`
`,e.exports.jsx(s.h3,{id:"scene-data-vs-render-data",children:e.exports.jsx(s.a,{href:"#scene-data-vs-render-data",children:"Scene Data vs. Render Data"})}),`
`,e.exports.jsx(s.p,{children:"To visualize a compelling 3d scene, we need data about the lights, camera and primitives (which themselves include textures, surfaces and geometry). As you have probably seen in computer science, we can store data in more or less effective ways depending on our intended use!"}),`
`,e.exports.jsxs(s.p,{children:["In this case, when ",e.exports.jsx(s.strong,{children:"building a scene"}),", we will use a ",e.exports.jsx(s.strong,{children:"transformation graph"}),' to make it easy to keep track of (and change) the position and orientation of primitives. Because the transformation graph organizes our scene in a way that reflects how the objects are built together, we can think of this as a "ideal" representation of our scene, so we decided to call it simply ',e.exports.jsx(s.code,{children:"SceneData"}),"."]}),`
`,e.exports.jsxs(s.p,{children:["However, when ",e.exports.jsx(s.strong,{children:"rendering a scene"}),", we need the ",e.exports.jsx(s.strong,{children:"final transformation matrices"})," to quickly get the final position and orientation of the primitives. These matricies are also known as cumulative transformation matricies, or ",e.exports.jsx(s.code,{children:"ctm"})," for short, and are stored directly ",e.exports.jsx(s.strong,{children:"with the primitives in a vector/list"}),'. We can think of this as a "render-optimized" representation of our scene, so we called it ',e.exports.jsx(s.code,{children:"RenderData"}),"."]}),`
`,e.exports.jsxs(s.p,{children:["See the two figures below. Your goal is to tranform ",e.exports.jsx(s.code,{children:"SceneData"})," to ",e.exports.jsx(s.code,{children:"RenderData"}),". Don't worry if you don't understand all the elements in the image, they'll be covered in this lab!"]}),`
`,e.exports.jsx(r,{images:[{src:"/labs/lab5/SceneVrsRender.png",alt:"TODO"}],figNumber:1,figCaption:"Transforming SceneData into RenderData."}),`
`,e.exports.jsx(r,{images:[{src:"/labs/lab5/SceneVrsRender\u20132.png",alt:"TODO"}],figNumber:2,figCaption:"Comparing Scene Graphs and List of Primitives data structures"}),`
`,e.exports.jsxs(s.p,{children:["In ",e.exports.jsx(s.a,{href:"#figure-1",children:"Figure 1"}),", notice how the ",e.exports.jsx(s.code,{children:"SceneGraph"})," and ",e.exports.jsx(s.code,{children:"PrimiviesList"})," are the only data structures that differentiate ",e.exports.jsx(s.code,{children:"SceneData"})," from ",e.exports.jsx(s.code,{children:"RenderData"}),". ",e.exports.jsx(s.a,{href:"#figure-2",children:"Figure 2"})," shows how the primitives and transformations are stored differently in these two data structures."]}),`
`,e.exports.jsxs("details",{children:[e.exports.jsx("summary",{children:"Why do we use an Array/Vector to render primitives?"}),e.exports.jsx(s.p,{children:"If you have started Ray 1, you might have noticed that one of the reasons Ray Tracing is so computationally expensive is because we need to check ray-primitive intersections, particularly when there are many primitives in the scene to check!"}),e.exports.jsxs(s.p,{children:["Using a list to iterate through the primitives is a simple way of doing this and sufficient for the requirements of this course, but there isn't any reason this part of the ",e.exports.jsx(s.code,{children:"RenderData"})," ",e.exports.jsx(s.strong,{children:"has"})," to be a simple list. If you want to be fancy, there are more efficient ways of doing it (see accelerated data structures like Octee, BVH and KD-Tree covered in lectures)."]})]}),`
`,e.exports.jsx(s.h2,{id:"scene-data",children:e.exports.jsx(s.a,{href:"#scene-data",children:"Scene Data"})}),`
`,e.exports.jsxs(s.p,{children:["Take a look at ",e.exports.jsx(s.code,{children:"parser/SceneData.h"}),". In this file, you will find all the data structures you need to build a scene. This section will go over the conceptual aspects of the scene elements."]}),`
`,e.exports.jsx(s.h3,{id:"global-data",children:e.exports.jsx(s.a,{href:"#global-data",children:"Global Data"})}),`
`,e.exports.jsxs(s.p,{children:["First, take a look at ",e.exports.jsx(s.code,{children:"SceneGlobalData"})," in ",e.exports.jsx(s.code,{children:"SceneData.h"}),":"]}),`
`,e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"struct"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"SceneGlobalData"}),`  {\r
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["   ",e.exports.jsx(s.span,{className:"pl-c",children:"// Scene global color coefficients"}),`\r
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["   ",e.exports.jsx(s.span,{className:"pl-k",children:"float"})," ka;  ",e.exports.jsx(s.span,{className:"pl-c",children:"// global ambient coefficient"}),`\r
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["   ",e.exports.jsx(s.span,{className:"pl-k",children:"float"})," kd;  ",e.exports.jsx(s.span,{className:"pl-c",children:"// global diffuse coefficient"}),`\r
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["   ",e.exports.jsx(s.span,{className:"pl-k",children:"float"})," ks;  ",e.exports.jsx(s.span,{className:"pl-c",children:"// global specular coefficient"}),`\r
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["   ",e.exports.jsx(s.span,{className:"pl-k",children:"float"})," kt;  ",e.exports.jsx(s.span,{className:"pl-c",children:"// global transparency coefficient"}),`\r
`]}),e.exports.jsx(s.span,{className:"code-line",children:`};
`})]})}),`
`,e.exports.jsx(s.p,{children:"This struct contains all the data relating to the entirety of the scene. In our case, it contains color coefficients that will be applied to the shading of every object in the scene. If you don't know exactly what these coefficents are, don't worry. For the purposes of this lab, you just need to know that each scene will contain global data which we will need to have when rendering it."}),`
`,e.exports.jsx(s.h3,{id:"lights",children:e.exports.jsx(s.a,{href:"#lights",children:"Lights"})}),`
`,e.exports.jsxs(s.p,{children:["Next, look at ",e.exports.jsx(s.code,{children:"LightType"})," in ",e.exports.jsx(s.code,{children:"SceneData.h"}),":"]}),`
`,e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"enum"})," ",e.exports.jsx(s.span,{className:"pl-k",children:"class"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"LightType"}),` {\r
`]}),e.exports.jsx(s.span,{className:"code-line",children:`    LIGHT_POINT, LIGHT_DIRECTIONAL, LIGHT_SPOT, LIGHT_AREA\r
`}),e.exports.jsx(s.span,{className:"code-line",children:`};
`})]})}),`
`,e.exports.jsxs(s.p,{children:[`To simulate different light sources in the real world, we use four types of virtual lights: Point, Directional, Spot, and Area.\r
You will know which one of these types of lights it is by the value of the enum `,e.exports.jsx(s.code,{children:"LightType"}),"."]}),`
`,e.exports.jsxs("details",{children:[e.exports.jsx("summary",{children:"What are Enums?"}),e.exports.jsx(s.p,{children:"Enums, or enumerated types, are user-defined data types that can take on a finite set of values. The values are defined during declaration, as shown above. Since they are enumerated, each value of the enum has an associated integer value, which by default starts with 0 for the first value. You probably have encountered enums already in Python or Java, where the convention is also to write the values in uppercase."})]}),`
`,e.exports.jsxs(s.p,{children:["Now, look at ",e.exports.jsx(s.code,{children:"SceneLightData"})," in ",e.exports.jsx(s.code,{children:"SceneData.h"}),":"]}),`
`,e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"struct"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"SceneLightData"}),` {\r
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["   ",e.exports.jsx(s.span,{className:"pl-k",children:"int"}),` id;\r
`]}),e.exports.jsx(s.span,{className:"code-line",children:`   LightType type;\r
`}),e.exports.jsx(s.span,{className:"code-line",children:`\r
`}),e.exports.jsx(s.span,{className:"code-line",children:`   SceneColor color;\r
`}),e.exports.jsxs(s.span,{className:"code-line",children:["   glm::vec3 function;  ",e.exports.jsx(s.span,{className:"pl-c",children:"// Attenuation function"}),`\r
`]}),e.exports.jsx(s.span,{className:"code-line",children:`\r
`}),e.exports.jsxs(s.span,{className:"code-line",children:["   glm::vec4 pos;       ",e.exports.jsx(s.span,{className:"pl-c",children:"// Not applicable to directional lights"}),`\r
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["   glm::vec4 dir;       ",e.exports.jsx(s.span,{className:"pl-c",children:"// Not applicable to point lights"}),`\r
`]}),e.exports.jsx(s.span,{className:"code-line",children:`\r
`}),e.exports.jsxs(s.span,{className:"code-line",children:["   ",e.exports.jsx(s.span,{className:"pl-k",children:"float"})," penumbra;      ",e.exports.jsx(s.span,{className:"pl-c",children:"// Only applicable to spot lights"}),`\r
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["   ",e.exports.jsx(s.span,{className:"pl-k",children:"float"})," angle;         ",e.exports.jsx(s.span,{className:"pl-c",children:"// Only applicable to spot lights"}),`\r
`]}),e.exports.jsx(s.span,{className:"code-line",children:`\r
`}),e.exports.jsxs(s.span,{className:"code-line",children:["   ",e.exports.jsx(s.span,{className:"pl-k",children:"float"})," width, height; ",e.exports.jsx(s.span,{className:"pl-c",children:"// Only applicable to area lights"}),`\r
`]}),e.exports.jsx(s.span,{className:"code-line",children:`};
`})]})}),`
`,e.exports.jsxs(s.p,{children:["Each light in our scene is represented with a struct that includes its ",e.exports.jsx(s.code,{children:"LightType"}),", its color, and other relevant information depending on the ",e.exports.jsx(s.code,{children:"LightType "}),"."]}),`
`,e.exports.jsxs("details",{children:[e.exports.jsx("summary",{children:"What is SceneColor?"}),e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-c",children:"// Struct to store a RGBA color in floats [0,1]"}),`\r
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"using"}),` SceneColor = glm::vec4;
`]})]})}),e.exports.jsx(s.p,{children:"You can look at lines 112 - 113 to see how color is represented. You should have already worked with with RGBA color in Brush and Filter."})]}),`
`,e.exports.jsxs(s.p,{children:[e.exports.jsx(s.strong,{children:"Point lights"})," are an single point in space that emits light equally in all directions (~lightbulb). They don't need a direction vector."]}),`
`,e.exports.jsxs(s.p,{children:[e.exports.jsx(s.strong,{children:"Directional lights"})," simulate light from a source that is extremely far away (e.g. the sun). Because of this, they don't have an attenuation function."]}),`
`,e.exports.jsxs(s.p,{children:[e.exports.jsx(s.strong,{children:"Spot lights"})," emit light in a cone shape (~a flashlight). They need an angle and radius to describe the dimentions of the cone, a direction to know where the base of the cone points to, and a position. The penumbra is how much the light fades away along the edges of the cone."]}),`
`,e.exports.jsxs(s.p,{children:[e.exports.jsx(s.strong,{children:"Area lights"})," are rectangles that emit light in all directions uniformly accross their surface."]}),`
`,e.exports.jsx(s.p,{children:e.exports.jsxs(s.em,{children:["Parts taken from ",e.exports.jsx(s.a,{href:"https://docs.unity3d.com/Manual/Lighting.html",children:"this article"})," where you can read more about types of light used in 3-d scenes."]})}),`
`,e.exports.jsx(s.h3,{id:"camera",children:e.exports.jsx(s.a,{href:"#camera",children:"Camera"})}),`
`,e.exports.jsxs(s.p,{children:["For the camera, take a look at ",e.exports.jsx(s.code,{children:"SceneCameraData"})," in ",e.exports.jsx(s.code,{children:"SceneData.h"}),":"]}),`
`,e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"struct"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"SceneCameraData"}),` {\r
`]}),e.exports.jsx(s.span,{className:"code-line",children:`   glm::vec4 pos;\r
`}),e.exports.jsx(s.span,{className:"code-line",children:`   glm::vec4 look;\r
`}),e.exports.jsx(s.span,{className:"code-line",children:`   glm::vec4 up;\r
`}),e.exports.jsx(s.span,{className:"code-line",children:`\r
`}),e.exports.jsxs(s.span,{className:"code-line",children:["   ",e.exports.jsx(s.span,{className:"pl-k",children:"float"}),` heightAngle;\r
`]}),e.exports.jsx(s.span,{className:"code-line",children:`};
`})]})}),`
`,e.exports.jsx(s.p,{children:"Look familiar? The camera is also just a struct with the relevant fields needed to describe its attributes! The position, look and up vectors of the camera are all described in world space (recall the discussion of world space/camera space from last week's transform's lab)."}),`
`,e.exports.jsx(s.h3,{id:"primitives",children:e.exports.jsx(s.a,{href:"#primitives",children:"Primitives"})}),`
`,e.exports.jsxs(s.p,{children:["Moving on to ",e.exports.jsx(s.code,{children:"PrimitiveType"}),":"]}),`
`,e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"enum"})," ",e.exports.jsx(s.span,{className:"pl-k",children:"class"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"PrimitiveType"}),` {\r
`]}),e.exports.jsx(s.span,{className:"code-line",children:`    PRIMITIVE_CUBE,\r
`}),e.exports.jsx(s.span,{className:"code-line",children:`    PRIMITIVE_CONE,\r
`}),e.exports.jsx(s.span,{className:"code-line",children:`    PRIMITIVE_CYLINDER,\r
`}),e.exports.jsx(s.span,{className:"code-line",children:`    PRIMITIVE_TORUS,\r
`}),e.exports.jsx(s.span,{className:"code-line",children:`    PRIMITIVE_SPHERE,\r
`}),e.exports.jsx(s.span,{className:"code-line",children:`    PRIMITIVE_MESH\r
`}),e.exports.jsx(s.span,{className:"code-line",children:`};
`})]})}),`
`,e.exports.jsxs(s.p,{children:["Similarly to ",e.exports.jsx(s.code,{children:"LightType"}),", we have ",e.exports.jsx(s.code,{children:"PrimitiveType"})," to keep track of different kinds of primitives. Again like the lights, the primitive types are used in a struct to describe a specific primitive in the scene:"]}),`
`,e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"struct"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"ScenePrimitive"}),` {\r
`]}),e.exports.jsx(s.span,{className:"code-line",children:`   PrimitiveType type;\r
`}),e.exports.jsxs(s.span,{className:"code-line",children:["   std::string meshfile;     ",e.exports.jsx(s.span,{className:"pl-c",children:"// Only applicable to meshes"}),`\r
`]}),e.exports.jsx(s.span,{className:"code-line",children:`   SceneMaterial material;\r
`}),e.exports.jsx(s.span,{className:"code-line",children:`};
`})]})}),`
`,e.exports.jsxs(s.p,{children:["All primitives will have a ",e.exports.jsx(s.code,{children:"PrimitiveType"})," and ",e.exports.jsx(s.code,{children:"SceneMaterial"}),`.\r
For meshes, the meshfile is a path to an .obj or equivalent file that has mesh geometry.\r
The material field describes all the important information about what the primitive looks like (its color, how shiny it is, texture, etc). You can look at the struct `,e.exports.jsx(s.code,{children:"SceneMaterial"})," for details, but don't worry if you don't understand any of the terms if they haven't yet been covered in Lecture."]}),`
`,e.exports.jsxs(s.p,{children:["Notice that unlike the lights or camera structs, there aren't any fields in ",e.exports.jsx(s.code,{children:"ScenePrimitive"})," that describe position or orientation. This is because it is more practical to use ",e.exports.jsx(s.strong,{children:"scene graphs"}),"  to manage this, especially when we have a lot of primitives!"]}),`
`,e.exports.jsx(s.h2,{id:"scene-graphs",children:e.exports.jsx(s.a,{href:"#scene-graphs",children:"Scene Graphs"})}),`
`,e.exports.jsxs(s.p,{children:["A ",e.exports.jsx(s.strong,{children:"scene graph"})," is a directed acyclical graph that holds all the primitives as well as the transformations applied to them. For this reason they can also be called ",e.exports.jsx(s.strong,{children:"transformation graphs"}),"."]}),`
`,e.exports.jsx(s.h3,{id:"transformations",children:e.exports.jsx(s.a,{href:"#transformations",children:"Transformations"})}),`
`,e.exports.jsx(s.p,{children:`In the Transforms lab, you learned to compose a series of rotation, scaling and translation matricies into a single transformation matrix.\r
While every transformation can be written as a matrix, it is easier when placing objects in a scene to just work with translation, scaling and rotation. This is why we separate these out from matricies, and work with four types of transformations:`}),`
`,e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"enum"}),` TransformationType {\r
`]}),e.exports.jsx(s.span,{className:"code-line",children:`   TRANSFORMATION_TRANSLATE, TRANSFORMATION_SCALE, TRANSFORMATION_ROTATE, TRANSFORMATION_MATRIX\r
`}),e.exports.jsx(s.span,{className:"code-line",children:`};
`})]})}),`
`,e.exports.jsxs(s.p,{children:["Just like lights and primitives, the type of transformation is then stored in a struct that contains the specific information. See ",e.exports.jsx(s.code,{children:"SceneTransformation"}),":"]}),`
`,e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"struct"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"SceneTransformation"}),` {\r
`]}),e.exports.jsx(s.span,{className:"code-line",children:`    TransformationType type;\r
`}),e.exports.jsx(s.span,{className:"code-line",children:`\r
`}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-c",children:"// The following fields are mutually exclusive."}),`\r
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    glm::vec3 translate; ",e.exports.jsx(s.span,{className:"pl-c",children:"// The translation vector. Only valid if transformation is a translation."}),`\r
`]}),e.exports.jsx(s.span,{className:"code-line",children:`\r
`}),e.exports.jsxs(s.span,{className:"code-line",children:["    glm::vec3 scale;     ",e.exports.jsx(s.span,{className:"pl-c",children:"// The scale vector. Only valid if transformation is a scale."}),`\r
`]}),e.exports.jsx(s.span,{className:"code-line",children:`\r
`}),e.exports.jsxs(s.span,{className:"code-line",children:["    glm::vec3 rotate;    ",e.exports.jsx(s.span,{className:"pl-c",children:"// The axis of rotation. Only valid if the transformation is a rotation."}),`\r
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"float"})," angle;         ",e.exports.jsx(s.span,{className:"pl-c",children:"// The rotation angle in RADIANS. Only valid if transformation is a rotation."}),`\r
`]}),e.exports.jsx(s.span,{className:"code-line",children:`\r
`}),e.exports.jsxs(s.span,{className:"code-line",children:["    glm::mat4x4 matrix;  ",e.exports.jsx(s.span,{className:"pl-c",children:"// The matrix for the transformation. Only valid if the transformation is a custom matrix."}),`\r
`]}),e.exports.jsx(s.span,{className:"code-line",children:`};
`})]})}),`
`,e.exports.jsx(s.h3,{id:"transformation-graphs",children:e.exports.jsx(s.a,{href:"#transformation-graphs",children:"Transformation Graphs"})}),`
`,e.exports.jsx(s.p,{children:"Scenes often have tens or hundrends of primitives, each with multiple different transformations! When creating a scene, it means that we'd have to know the exact final position and orientation of every primitive. Instead, we apply a series of transformations to objects, like moving them around, scaling, or rotating them. Transformation Graphs store these operations in a helpful way."}),`
`,e.exports.jsxs(s.p,{children:["Take a look at ",e.exports.jsx(s.code,{children:"SceneNode"}),":"]}),`
`,e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"struct"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"SceneNode"}),` {\r
`]}),e.exports.jsx(s.span,{className:"code-line",children:`   std::vector<SceneTransformation*> transformations;\r
`}),e.exports.jsx(s.span,{className:"code-line",children:`\r
`}),e.exports.jsx(s.span,{className:"code-line",children:`   std::vector<ScenePrimitive*> primitives;\r
`}),e.exports.jsx(s.span,{className:"code-line",children:`\r
`}),e.exports.jsx(s.span,{className:"code-line",children:`   std::vector<SceneNode*> children;\r
`}),e.exports.jsx(s.span,{className:"code-line",children:`};
`})]})}),`
`,e.exports.jsxs(s.p,{children:["Here we have created a node struct that will allow us to build a ",e.exports.jsx(s.strong,{children:"transformation graph"}),". If a ",e.exports.jsx(s.code,{children:"SceneNode"})," has ",e.exports.jsx(s.code,{children:"children"}),", it will also likely contain ",e.exports.jsx(s.code,{children:"transformations"})," to apply to those ",e.exports.jsx(s.code,{children:"children"}),", and so on, until we get to a node that has ",e.exports.jsx(s.code,{children:"primitives"}),"."]}),`
`,e.exports.jsxs(s.p,{children:["Note that since ",e.exports.jsx(s.code,{children:"SceneNode"}),"s exist to avoid repetitions of transformations applied to primitives, they cannot have both ",e.exports.jsx(s.code,{children:"transformations"})," and ",e.exports.jsx(s.code,{children:"primitives"}),", or ",e.exports.jsx(s.code,{children:"children"})," and ",e.exports.jsx(s.code,{children:"primitives"}),"."]}),`
`,e.exports.jsxs("details",{children:[e.exports.jsx("summary",{children:"Example of a cityscape"}),e.exports.jsx(s.p,{children:`If our scene is a city, it would be senseless to describe the positions of all the windows by their distance from the center of the city. It would be much more sensible to describe each window's position relative to the building it is part of, place the building on the street it is on, and then describe the street's position relative to the center of the city.\r
Moving a house to a different position would be as simple as applying a transformation matrix to the house, and consequently having that translation applied to every window and primitive it contains.`})]}),`
`,e.exports.jsxs("details",{children:[e.exports.jsx("summary",{children:"Example of a cityscape continued"}),e.exports.jsx(s.p,{children:"In our city, we can define a first grouping as the streets, which can themselves be made up of sub-groupings consisting of buildings, which can be made of further sub-groupings of windows, doors and roofs, until we get to the primitives like cubes, pyramids, and cylinders."})]}),`
`,e.exports.jsx(s.h4,{id:"order-of-transformations",children:e.exports.jsx(s.a,{href:"#order-of-transformations",children:"Order of Transformations"})}),`
`,e.exports.jsxs(s.p,{children:["You will now learn how to use ",e.exports.jsx(s.strong,{children:"transformation graphs"})," to build final transformation matrices for each primitive."]}),`
`,e.exports.jsx(s.div,{className:"warning-callout callout",children:e.exports.jsxs(s.p,{children:["A final transformation matrix is a matrix that has all the transformations done to an primitive, transforming it to its final position and orientation in the scene. It is also called a ",e.exports.jsx(s.strong,{children:"cumulative transformation matrix"}),"."]})}),`
`,e.exports.jsx(s.p,{children:"Consider the graph below that represents four primitives in a scene (two spheres, one cube, one cone and a cylinder):"}),`
`,e.exports.jsx(r,{images:[{src:"/labs/lab5/Parsing_Lab_Graph\u20131.png",alt:"TODO"}],figNumber:3,figCaption:"Transformation Graph with 5 Primitives"}),`
`,e.exports.jsxs(s.p,{children:["As mentioned in ",e.exports.jsx(s.strong,{children:"3.2."}),", all nodes are ",e.exports.jsx(s.code,{children:"SceneNode"}),"s and can be thought of as groupings of objects. Leaf nodes contain only ",e.exports.jsx(s.code,{children:"primitives"}),". Non-leaf nodes contain ",e.exports.jsx(s.code,{children:"transformations"})," (denoted ",e.exports.jsx(s.code,{children:"T1"}),", ",e.exports.jsx(s.code,{children:"T2"}),",",e.exports.jsx(s.code,{children:"R1"})," etc.). The transformation(s) of non-leaf node are applied to the ",e.exports.jsx(s.code,{children:"children"})," nodes."]}),`
`,e.exports.jsxs(s.p,{children:["Some nodes contain multiple transformations, such as ",e.exports.jsx(s.code,{children:"T5, R5, S6"}),". In fact, as we saw before in 3.2., all nodes technically contain an list of transformations of type ",e.exports.jsx(s.code,{children:"std::vector<SceneTransformation*>"}),"."]}),`
`,e.exports.jsx(s.div,{className:"warning-callout callout",children:e.exports.jsxs(s.p,{children:["If ",e.exports.jsx(s.code,{children:"SceneNodes"})," contain multiple transformations, by convention they are to be applied in the ",e.exports.jsx(s.strong,{children:"opposite order"})," in which they appear in the list or ",e.exports.jsx(s.code,{children:"std::vector"}),"."]})}),`
`,e.exports.jsxs(s.div,{className:"task-callout callout",children:[e.exports.jsxs(s.p,{children:["For the Scene Graph in ",e.exports.jsx(s.a,{href:"#figure-3",children:"Figure 3"}),", write a final transformation matrix for the Cube, Cone and Cylinder."]}),e.exports.jsxs(s.ul,{children:[`
`,e.exports.jsxs(s.li,{children:["Your answer should be in terms of the matrices found in the graph, like ",e.exports.jsx(s.code,{children:"T1"}),", ",e.exports.jsx(s.code,{children:"R2"}),", etc."]}),`
`,e.exports.jsx(s.li,{children:"Keep in mind that order matters when multiplying matricies!"}),`
`]})]}),`
`,e.exports.jsx(s.h4,{id:"matrices",children:e.exports.jsx(s.a,{href:"#matrices",children:"Matrices"})}),`
`,e.exports.jsx(s.p,{children:"Now, consider the graph below:"}),`
`,e.exports.jsx(r,{images:[{src:"/labs/lab5/Parsing_Lab_Graph\u20132.png",alt:"TODO"}],figNumber:4,figCaption:"Transformation Graph with 5 Primitives"}),`
`,e.exports.jsx(s.p,{children:"Remember how in the Transforms lab you learned to write a matrix in terms of multiple transformations like Translation, Scaling and Rotation? In the graph above, we have subsituted all nodes containing multiple transformations with a single transformation matrix."}),`
`,e.exports.jsx(s.div,{className:"task-callout callout",children:e.exports.jsxs(s.p,{children:["Write matrices ",e.exports.jsx(s.code,{children:"M1"}),", ",e.exports.jsx(s.code,{children:"M2"}),", ",e.exports.jsx(s.code,{children:"M3"})," and ",e.exports.jsx(s.code,{children:"M4"})," in terms of the transformations they correspond to in ",e.exports.jsx(s.a,{href:"#figure-3",children:"Figure 3"}),"."]})}),`
`,e.exports.jsxs(s.p,{children:["Note that while in ",e.exports.jsx(s.a,{href:"#figure-4",children:"Figure 4"}),", we replaced nodes containing multiple transformations ",e.exports.jsx(s.code,{children:"T1"}),", ",e.exports.jsx(s.code,{children:"R2"}),", ",e.exports.jsx(s.code,{children:"S1"}),", etc. with transformation matrices ",e.exports.jsx(s.code,{children:"M1"}),", ",e.exports.jsx(s.code,{children:"M2"}),`, etc. , in practice you will always be dealing with a list of transformations.\r
In fact, since `,e.exports.jsx(s.code,{children:"TRANSFORMATION_MATRIX"})," is a ",e.exports.jsx(s.code,{children:"TransformationType"})," just like any other, you will have transformation matrices show up alongside translation, scaling and rotation transformations in the same ",e.exports.jsx(s.code,{children:"std::vector<SceneTransformation*> transformations"}),"."]}),`
`,e.exports.jsx(s.h4,{id:"traversing-the-graph",children:e.exports.jsx(s.a,{href:"#traversing-the-graph",children:"Traversing the Graph"})}),`
`,e.exports.jsx(s.p,{children:"In Task 1, you should have noticed that we apply the same transformations to different primitives."}),`
`,e.exports.jsxs(s.div,{className:"task-callout callout",children:[e.exports.jsx(s.p,{children:"How might you build up the cumulative transformation matrices as you navigate the graph?"}),e.exports.jsx(s.p,{children:"Explain why traversing a scene graph from the root node every time each object is rendered is inefficient, and propose a more efficient approach."})]}),`
`,e.exports.jsx(s.h2,{id:"render-data",children:e.exports.jsx(s.a,{href:"#render-data",children:"Render Data"})}),`
`,e.exports.jsxs(s.p,{children:["Now that you know all about global data, lights, cameras, primitives and transformations, you can code your own implementation to turn ",e.exports.jsx(s.code,{children:"SceneData"})," into ",e.exports.jsx(s.code,{children:"RenderData"}),"!"]}),`
`,e.exports.jsx(s.h3,{id:"implementing-sceneloaderparse",children:e.exports.jsx(s.a,{href:"#implementing-sceneloaderparse",children:"Implementing SceneLoader::parse()"})}),`
`,e.exports.jsxs(s.p,{children:["Whenever we would like to load a scene, we can call ",e.exports.jsx(s.code,{children:"SceneParser::parse()"}),`.\r
The stencil code already covers the parsing for the XML scene file and what you should do is to create the `,e.exports.jsx(s.code,{children:"RenderData"})," based on the information inside the parser's ",e.exports.jsx(s.code,{children:"ScenefileReader"}),". In the ",e.exports.jsx(s.code,{children:"parse()"})," function, a new ",e.exports.jsx(s.code,{children:"ScenefileReader"})," instance will be created and try to parse the given file. The ",e.exports.jsx(s.code,{children:"ScenefileReader"})," conveniently parses all the scene data found in the scene files for you, and has all the elements mentioned in the Scene Data section."]}),`
`,e.exports.jsxs(s.p,{children:["In ",e.exports.jsx(s.code,{children:"SceneLoader::load()"}),", you should obtain the global data for the scene, the camera data and the lighting. You should also traverse through the Scene Graph and calculate the cumulative transformation matrix for each of the primitives. All data described above can be packed into the ",e.exports.jsx(s.code,{children:"RenderData"})," structure as a unified interface for you to render your scenes for your future assignments."]}),`
`,e.exports.jsxs(s.p,{children:["Refer to ",e.exports.jsx(s.code,{children:"ScenefileReader.h"})," and the ",e.exports.jsx(s.code,{children:"RenderData"})," struct in ",e.exports.jsx(s.code,{children:"SceneParser.h"})," to understand how you are given the scene data and what you need to turn it into."]}),`
`,e.exports.jsx(s.h4,{id:"global-data-1",children:e.exports.jsx(s.a,{href:"#global-data-1",children:"Global data"})}),`
`,e.exports.jsx(s.div,{className:"task-callout callout",children:e.exports.jsxs(s.p,{children:["In ",e.exports.jsx(s.code,{children:"SceneParser::parse()"}),", use the ",e.exports.jsx(s.code,{children:"fileReader"})," to load the Global Data into the ",e.exports.jsx(s.code,{children:"renderData"})," struct."]})}),`
`,e.exports.jsx(s.h4,{id:"camera-data",children:e.exports.jsx(s.a,{href:"#camera-data",children:"Camera data"})}),`
`,e.exports.jsx(s.div,{className:"task-callout callout",children:e.exports.jsxs(s.p,{children:["Next, use the ",e.exports.jsx(s.code,{children:"fileReader"})," to load the Camera Data into the ",e.exports.jsx(s.code,{children:"renderData"})," struct."]})}),`
`,e.exports.jsx(s.h4,{id:"lights-1",children:e.exports.jsx(s.a,{href:"#lights-1",children:"Lights"})}),`
`,e.exports.jsx(s.div,{className:"task-callout callout",children:e.exports.jsxs(s.p,{children:["Similarly, use the ",e.exports.jsx(s.code,{children:"fileReader"})," to load the Lights into the ",e.exports.jsx(s.code,{children:"renderData"})," struct."]})}),`
`,e.exports.jsx(s.h4,{id:"root-node",children:e.exports.jsx(s.a,{href:"#root-node",children:"Root Node"})}),`
`,e.exports.jsx(s.p,{children:"Now we are ready for the less trivial stuff, that is traversing the Scene Graph and storing the final transformation matrices with each primitive!"}),`
`,e.exports.jsx(s.div,{className:"task-callout callout",children:e.exports.jsxs(s.p,{children:["Get the Root Node of the Scene Graph from the ",e.exports.jsx(s.code,{children:"fileReader"}),"."]})}),`
`,e.exports.jsx(s.h4,{id:"depth-first-search",children:e.exports.jsx(s.a,{href:"#depth-first-search",children:"Depth-First Search"})}),`
`,e.exports.jsx(s.div,{className:"task-callout callout",children:e.exports.jsxs(s.p,{children:["Perform a depth-first search starting with the Root Node of the Scene Graph. While you are navigating the Scene Graph, build the cumulative transformation matrices, and load them along with their corresponding primitive into ",e.exports.jsx(s.code,{children:"RenderData"}),"."]})}),`
`,e.exports.jsxs(s.p,{children:["Hint: it might help to write a helper function which is called during ",e.exports.jsx(s.code,{children:"SceneParser::parse()"}),`.\r
Think about how to build the cumulative transformation matrix as you navigate the graph. You can refer to your answers from Task 1 and Task 3, as well as `,e.exports.jsx(s.a,{href:"#figure-2",children:"Figure 2"})," and ",e.exports.jsx(s.a,{href:"#figure-3",children:"Figure 3"}),"."]}),`
`,e.exports.jsx(s.h3,{id:"testing-scenes",children:e.exports.jsx(s.a,{href:"#testing-scenes",children:"Testing scenes"})}),`
`,e.exports.jsxs(s.p,{children:["You should now be able to test if you are properly loading scenes. You can load up any .xml file (like ",e.exports.jsx(s.code,{children:"chess.xml"}),`), by running the lab and going to file > open in the window that pops up.\r
If everything goes well, you should see an image that looks like this:`]}),`
`,e.exports.jsx(r,{images:[{src:"/labs/lab5/Chess.png",alt:"TODO"}],figNumber:5,figCaption:"A Successfuly loaded chess.xml"}),`
`,e.exports.jsx(s.p,{children:"Note that loading scenes into the window will help you test the camera, primitives and transformation data, but not necessairly the lights, since the shading done by our support code is very basic."}),`
`,e.exports.jsx(s.h2,{id:"optional-creating-your-own-3-d-scenes",children:e.exports.jsx(s.a,{href:"#optional-creating-your-own-3-d-scenes",children:"(Optional) Creating your own 3-d scenes"})}),`
`,e.exports.jsxs(s.p,{children:[`You might want to work with the scene files directly for a final project, in order to create your own 3-d scenes.\r
Scene files are written using the XML format, which our `,e.exports.jsx(s.code,{children:"ScenefileReader"}),` reads for you.\r
You can refer to this lab for the conceptual aspects of scene files, but for the specifics of the XML format, you should check out the dedicated page in the Docs tab.`]}),`
`,e.exports.jsx(s.h2,{id:"end",children:e.exports.jsx(s.a,{href:"#end",children:"End"})}),`
`,e.exports.jsx(s.p,{children:`To be checked off, you should have your answers to conceptual questions ready (Tasks 1 through 3).\r
You should also be able to show a scene that loads correctly into the window as explained in 4.2.`}),`
`,e.exports.jsx(a,{})]})]})}function h(t={}){const{wrapper:s}=t.components||{};return s?e.exports.jsx(s,Object.assign({},t,{children:e.exports.jsx(n,t)})):n(t)}export{h as default,c as documentProps};
