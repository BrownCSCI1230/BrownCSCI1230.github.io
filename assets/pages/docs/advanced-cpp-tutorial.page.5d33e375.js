import{j as s}from"../../chunk-37395b21.js";import{M as l}from"../../chunk-a40e06f3.js";const p={title:"Advanced C++ Tutorial"};function n(a){const e=Object.assign({nav:"nav",ol:"ol",li:"li",a:"a",main:"main",h1:"h1",p:"p",h2:"h2",pre:"pre",code:"code",span:"span",em:"em",strong:"strong",h3:"h3"},a.components);return s.exports.jsxs(s.exports.Fragment,{children:[s.exports.jsx(e.nav,{className:"toc",children:s.exports.jsx(e.ol,{className:"toc-level toc-level-1",children:s.exports.jsxs(e.li,{className:"toc-item toc-item-h1",children:[s.exports.jsx(e.a,{className:"toc-link toc-link-h1",href:"#advanced-c-tutorial",children:"Advanced C++ Tutorial"}),s.exports.jsxs(e.ol,{className:"toc-level toc-level-2",children:[s.exports.jsx(e.li,{className:"toc-item toc-item-h2",children:s.exports.jsx(e.a,{className:"toc-link toc-link-h2",href:"#dynamic-memory-allocation-raii-and-smart-pointers",children:"Dynamic Memory Allocation, RAII and Smart Pointers"})}),s.exports.jsx(e.li,{className:"toc-item toc-item-h2",children:s.exports.jsx(e.a,{className:"toc-link toc-link-h2",href:"#operator-overloading-and-user-defined-literals",children:"Operator Overloading and User Defined Literals"})}),s.exports.jsx(e.li,{className:"toc-item toc-item-h2",children:s.exports.jsx(e.a,{className:"toc-link toc-link-h2",href:"#pointers-and-references-reprise",children:"Pointers and References (Reprise)"})}),s.exports.jsx(e.li,{className:"toc-item toc-item-h2",children:s.exports.jsx(e.a,{className:"toc-link toc-link-h2",href:"#pointer-arithmetic",children:"Pointer Arithmetic"})}),s.exports.jsx(e.li,{className:"toc-item toc-item-h2",children:s.exports.jsx(e.a,{className:"toc-link toc-link-h2",href:"#lambdas-and-functional-programming",children:"Lambdas and Functional Programming"})}),s.exports.jsxs(e.li,{className:"toc-item toc-item-h2",children:[s.exports.jsx(e.a,{className:"toc-link toc-link-h2",href:"#runtime-polymorphism",children:"Runtime Polymorphism"}),s.exports.jsxs(e.ol,{className:"toc-level toc-level-3",children:[s.exports.jsx(e.li,{className:"toc-item toc-item-h3",children:s.exports.jsx(e.a,{className:"toc-link toc-link-h3",href:"#function-type-proxies",children:"Function Type Proxies"})}),s.exports.jsx(e.li,{className:"toc-item toc-item-h3",children:s.exports.jsx(e.a,{className:"toc-link toc-link-h3",href:"#existential-types",children:"Existential Types"})}),s.exports.jsx(e.li,{className:"toc-item toc-item-h3",children:s.exports.jsx(e.a,{className:"toc-link toc-link-h3",href:"#virtual-functions",children:"Virtual Functions"})})]})]})]})]})})}),s.exports.jsxs(e.main,{children:[`
`,`
`,s.exports.jsx(e.h1,{id:"advanced-c-tutorial",children:s.exports.jsx(e.a,{href:"#advanced-c-tutorial",children:"Advanced C++ Tutorial"})}),`
`,s.exports.jsx(e.p,{children:`In lab 1, we introduced you to the minimum C++ features you'll need for programming work in this course.
In this lab, we'll talk about additional C++ features you can use to improve your program design. We'll also cover things happening under the hood for you to have a deeper understanding of the language in general.`}),`
`,s.exports.jsx(e.h2,{id:"dynamic-memory-allocation-raii-and-smart-pointers",children:s.exports.jsx(e.a,{href:"#dynamic-memory-allocation-raii-and-smart-pointers",children:"Dynamic Memory Allocation, RAII and Smart Pointers"})}),`
`,s.exports.jsx(e.p,{children:"Coming soon..."}),`
`,s.exports.jsx(e.h2,{id:"operator-overloading-and-user-defined-literals",children:s.exports.jsx(e.a,{href:"#operator-overloading-and-user-defined-literals",children:"Operator Overloading and User Defined Literals"})}),`
`,s.exports.jsx(e.p,{children:"Coming soon..."}),`
`,s.exports.jsx(e.h2,{id:"pointers-and-references-reprise",children:s.exports.jsx(e.a,{href:"#pointers-and-references-reprise",children:"Pointers and References (Reprise)"})}),`
`,s.exports.jsx(e.p,{children:"In lab 1, we mentioned that we can access the entity that a pointer points to by dereferencing the pointer, and that a reference represents an entity at a particular memory address. It seems that there should be a connection between pointers and references, indeed, we obtain a reference when we dereference a pointer:"}),`
`,s.exports.jsx(e.pre,{className:"language-cpp",children:s.exports.jsxs(e.code,{className:"language-cpp code-highlight",children:[s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-k",children:"auto"})," x = ",s.exports.jsx(e.span,{className:"pl-c1",children:"42"}),`;
`]}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-k",children:"auto"})," y = Rectangle{ .",s.exports.jsx(e.span,{className:"pl-smi",children:"length"})," = ",s.exports.jsx(e.span,{className:"pl-c1",children:"4"}),", .",s.exports.jsx(e.span,{className:"pl-smi",children:"width"})," = ",s.exports.jsx(e.span,{className:"pl-c1",children:"2"}),` };
`]}),s.exports.jsx(e.span,{className:"code-line",children:`
`}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-k",children:"auto"}),` px = &x;
`]}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-k",children:"auto"}),` py = &y;
`]}),s.exports.jsx(e.span,{className:"code-line",children:`
`}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-k",children:"auto"}),"& refx = *px; ",s.exports.jsx(e.span,{className:"pl-c",children:'// same as "auto& refx = x;"'}),`
`]}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-k",children:"auto"}),"& yLength = py->length; ",s.exports.jsx(e.span,{className:"pl-c",children:'// same as "auto& yLength = y.length;"'}),`
`]}),s.exports.jsx(e.span,{className:"code-line",children:`
`}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-c",children:"// we can verify that dereferencing a pointer indeed gives us a reference"}),`
`]}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-en",children:"static_assert"}),`(std::same_as<decltype(*px), int&>);
`]})]})}),`
`,s.exports.jsx(e.p,{children:"This is precisely the reason why dereferencing a pointer allows us to modify the object it points to, the same way as how we modify something via a reference."}),`
`,s.exports.jsxs(e.p,{children:["One problem with the basic form of references we've learned so far, is that they cannot bind to ",s.exports.jsx(e.em,{children:"values"})," (",s.exports.jsx(e.a,{href:"https://en.cppreference.com/w/cpp/language/value_category#rvalue",target:"_blank",rel:"noopener noreferrer",children:"rvalue"})," in C++ terminology). The reason is obvious, values such as ",s.exports.jsx(e.code,{children:"123"})," or ",s.exports.jsx(e.code,{children:"3.14"})," do not have a memory address because they are not stored in memory by some variable. The same applies to function parameters, we cannot pass values to reference parameters."]}),`
`,s.exports.jsx(e.pre,{className:"language-cpp",children:s.exports.jsxs(e.code,{className:"language-cpp code-highlight",children:[s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-k",children:"auto"})," ",s.exports.jsx(e.span,{className:"pl-en",children:"func"}),"(std::vector<",s.exports.jsx(e.span,{className:"pl-k",children:"int"}),`>& things)->void {
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["    ",s.exports.jsx(e.span,{className:"pl-c",children:"// empty"}),`
`]}),s.exports.jsx(e.span,{className:"code-line",children:`}
`}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-k",children:"auto"})," x = ",s.exports.jsx(e.span,{className:"pl-c1",children:"42"}),`;
`]}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-k",children:"auto"})," things = std::vector{ ",s.exports.jsx(e.span,{className:"pl-c1",children:"1"}),", ",s.exports.jsx(e.span,{className:"pl-c1",children:"2"}),", ",s.exports.jsx(e.span,{className:"pl-c1",children:"3"}),", ",s.exports.jsx(e.span,{className:"pl-c1",children:"4"}),` };
`]}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-k",children:"auto"}),"& refx = x; ",s.exports.jsx(e.span,{className:"pl-c",children:"// OK, bind to a variable"}),`
`]}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-c",children:"// auto& incorrectRef = 42; // error, (lvalue) reference cannot bind to (r)value"}),`
`]}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-en",children:"func"}),"(things); ",s.exports.jsx(e.span,{className:"pl-c",children:"// OK, reference parameter binds to 'things'"}),`
`]}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-c",children:"// func(std::vector{ 1, 2, 3, 4 }); // error, (lvalue) reference parameter cannot bind to (r)value"}),`
`]})]})}),`
`,s.exports.jsxs(e.p,{children:["This can be inconvenient in some cases. Ideally, we'd want something that behaves like a reference when we bind it to a variable, and like a new variable when we provide it a value. Luckily, we do have something exactly like this in C++ called ",s.exports.jsx(e.em,{children:"forwarding"})," ",s.exports.jsx(e.em,{children:"references"})," in the form of ",s.exports.jsx(e.code,{children:"auto&&"}),"."]}),`
`,s.exports.jsxs("details",{children:[s.exports.jsx("summary",{children:"Be careful though"}),s.exports.jsxs(e.p,{children:[s.exports.jsx(e.code,{children:"&&"})," after a concrete type, like ",s.exports.jsx(e.code,{children:"int&&"})," or ",s.exports.jsx(e.code,{children:"std::vector<int>&&"}),", does not form a forwarding reference! These are ",s.exports.jsx(e.em,{children:"rvalue references"})," which are outside the scope of this doc. You can learn more about rvalue references ",s.exports.jsx(e.a,{href:"https://en.cppreference.com/w/cpp/language/reference#Rvalue_references",target:"_blank",rel:"noopener noreferrer",children:"here"}),", if you're interested."]})]}),`
`,s.exports.jsx(e.pre,{className:"language-cpp",children:s.exports.jsxs(e.code,{className:"language-cpp code-highlight",children:[s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-k",children:"auto"})," ",s.exports.jsx(e.span,{className:"pl-en",children:"betterFunc"}),"(",s.exports.jsx(e.span,{className:"pl-k",children:"auto"}),`&& things)->void {
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["  ",s.exports.jsx(e.span,{className:"pl-c",children:"// empty"}),`
`]}),s.exports.jsx(e.span,{className:"code-line",children:`}
`}),s.exports.jsx(e.span,{className:"code-line",children:`
`}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-k",children:"auto"})," x = ",s.exports.jsx(e.span,{className:"pl-c1",children:"42"}),`;
`]}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-k",children:"auto"})," things = std::vector{ ",s.exports.jsx(e.span,{className:"pl-c1",children:"1"}),", ",s.exports.jsx(e.span,{className:"pl-c1",children:"2"}),", ",s.exports.jsx(e.span,{className:"pl-c1",children:"3"}),", ",s.exports.jsx(e.span,{className:"pl-c1",children:"4"}),` };
`]}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-k",children:"auto"}),"&& refx = x; ",s.exports.jsx(e.span,{className:"pl-c",children:"// OK, bind to a variable, same as 'auto& refx = x;'"}),`
`]}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-k",children:"auto"}),"&& forwardRef = ",s.exports.jsx(e.span,{className:"pl-c1",children:"42"}),"; ",s.exports.jsx(e.span,{className:"pl-c",children:"// OK, creates a new variable as if 'auto forwardRef = 42;'"}),`
`]}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-en",children:"betterFunc"}),"(things); ",s.exports.jsx(e.span,{className:"pl-c",children:"// OK, reference parameter binds to 'things'"}),`
`]}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-en",children:"betterFunc"}),"(std::vector{ ",s.exports.jsx(e.span,{className:"pl-c1",children:"1"}),", ",s.exports.jsx(e.span,{className:"pl-c1",children:"2"}),", ",s.exports.jsx(e.span,{className:"pl-c1",children:"3"}),", ",s.exports.jsx(e.span,{className:"pl-c1",children:"4"})," }); ",s.exports.jsx(e.span,{className:"pl-c",children:"// OK, as if the parameter type is non-reference"}),`
`]})]})}),`
`,s.exports.jsx(e.h2,{id:"pointer-arithmetic",children:s.exports.jsx(e.a,{href:"#pointer-arithmetic",children:"Pointer Arithmetic"})}),`
`,s.exports.jsx(e.p,{children:"We've discussed in lab 1 that a pointer is an integer storing a memory address. What will happen though, if we perform integer arithmetics on pointers? Consider the following example"}),`
`,s.exports.jsx(e.pre,{className:"language-cpp",children:s.exports.jsxs(e.code,{className:"language-cpp code-highlight",children:[s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-k",children:"auto"})," p = ",s.exports.jsx(e.span,{className:"pl-k",children:"reinterpret_cast"}),"<",s.exports.jsx(e.span,{className:"pl-k",children:"int"}),"*>(",s.exports.jsx(e.span,{className:"pl-c1",children:"42"}),"); ",s.exports.jsx(e.span,{className:"pl-c",children:"// cast some random integer to a pointer"}),`
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["p += ",s.exports.jsx(e.span,{className:"pl-c1",children:"1"}),`;
`]}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-k",children:"auto"})," x = ",s.exports.jsx(e.span,{className:"pl-k",children:"reinterpret_cast"}),"<",s.exports.jsx(e.span,{className:"pl-k",children:"unsigned"})," ",s.exports.jsx(e.span,{className:"pl-k",children:"long"})," ",s.exports.jsx(e.span,{className:"pl-k",children:"long"}),">(p); ",s.exports.jsx(e.span,{className:"pl-c",children:"// cast pointer back to integer"}),`
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["std::cout << x; ",s.exports.jsx(e.span,{className:"pl-c",children:"// what will you see here?"}),`
`]})]})}),`
`,s.exports.jsxs(e.p,{children:["You would probably think ",s.exports.jsx(e.code,{children:"x"})," is ",s.exports.jsx(e.code,{children:"43"}),", however depending on your hardware platform, you're likely to see ",s.exports.jsx(e.code,{children:"46"}),"! Why is that?"]}),`
`,s.exports.jsxs(e.p,{children:["This is because pointer arithmetic has array semantics, meaning if you have a pointer ",s.exports.jsx(e.code,{children:"p"})," pointing to the address of some object of type ",s.exports.jsx(e.code,{children:"T"}),", ",s.exports.jsx(e.code,{children:"p + n"})," assumes that there is an array of ",s.exports.jsx(e.code,{children:"T"}),"s stored in contiguous memory, and ",s.exports.jsx(e.code,{children:"p + n"})," evaluates to the address of the ",s.exports.jsx(e.code,{children:"n"}),"-th object after the object that ",s.exports.jsx(e.code,{children:"p"})," points to. In the above example, ",s.exports.jsx(e.code,{children:"x"})," contains the address of a (hypothetical) integer next to the (hypotetical) integer whose address is ",s.exports.jsx(e.code,{children:"42"}),". And therefore the value of ",s.exports.jsx(e.code,{children:"x"})," would be ",s.exports.jsx(e.code,{children:"42 + sizeof(int)"}),", since ",s.exports.jsx(e.code,{children:"sizeof(int)"})," is likely ",s.exports.jsx(e.code,{children:"4"})," on most common hardware platforms, you see ",s.exports.jsx(e.code,{children:"46"})," when you print out ",s.exports.jsx(e.code,{children:"x"}),"."]}),`
`,s.exports.jsxs(e.p,{children:[s.exports.jsx(e.code,{children:"n"})," can also be a negative integer in ",s.exports.jsx(e.code,{children:"p + n"}),", let ",s.exports.jsx(e.code,{children:"m = -n"}),", ",s.exports.jsx(e.code,{children:"p + n"})," would be the same as ",s.exports.jsx(e.code,{children:"p - m"}),", meaning the address of the ",s.exports.jsx(e.code,{children:"m"}),"-th object before ",s.exports.jsx(e.code,{children:"*p"}),"."]}),`
`,s.exports.jsxs(e.p,{children:["Pointer arithmetic is common in C/C++, and ",s.exports.jsx(e.code,{children:"*(p + n)"})," is unwieldy, the language therefore defines a syntactic sugar for us to do the exact same thing, we may use the indexing operator ",s.exports.jsx(e.code,{children:"p[n]"})," to represent ",s.exports.jsx(e.code,{children:"*(p + n)"}),", the indexing operator syntax is the exact same as explicit pointer arithmetic."]}),`
`,s.exports.jsxs("details",{children:[s.exports.jsx("summary",{children:"Secrets behind C arrays"}),s.exports.jsxs(e.p,{children:["If you have prior experience in C/C++, you may have noticed that we always use ",s.exports.jsx(e.code,{children:"std::array<T, N>"})," instead of the C array ",s.exports.jsx(e.code,{children:"T[N]"}),". C arrays behave just like a pointer in many cases, and we concluded that this is unnecessary complexity for beginners."]}),s.exports.jsx(e.pre,{className:"language-cpp",children:s.exports.jsxs(e.code,{className:"language-cpp code-highlight",children:[s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-k",children:"int"})," x1[",s.exports.jsx(e.span,{className:"pl-c1",children:"3"}),`];
`]}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-k",children:"auto"})," x2 = std::array<",s.exports.jsx(e.span,{className:"pl-k",children:"int"}),", ",s.exports.jsx(e.span,{className:"pl-c1",children:"3"}),`>{};
`]}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-k",children:"auto"})," y1 = x1; ",s.exports.jsx(e.span,{className:"pl-c",children:"// this is a pointer! not a copy of the 'x1' array!"}),`
`]}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-k",children:"auto"})," y2 = x2; ",s.exports.jsx(e.span,{className:"pl-c",children:"// this is a copy of the 'x2' array!"}),`
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["y1[",s.exports.jsx(e.span,{className:"pl-c1",children:"0"}),"] = ",s.exports.jsx(e.span,{className:"pl-c1",children:"42"}),"; ",s.exports.jsx(e.span,{className:"pl-c",children:"// this is the same as 'x1[0] = 42'"}),`
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["y2[",s.exports.jsx(e.span,{className:"pl-c1",children:"0"}),"] = ",s.exports.jsx(e.span,{className:"pl-c1",children:"42"}),"; ",s.exports.jsx(e.span,{className:"pl-c",children:"// this does nothing to x2, since it's a copy"}),`
`]})]})}),s.exports.jsxs(e.p,{children:["The reason behind this oddity is that C arrays automatically decay to the pointer to its first element. Interestingly, the C++ standard only defines the builtin indexing operator on pointers, it is never said that (C) arrays can be indexed. What happens when the compiler sees ",s.exports.jsx(e.code,{children:"x1[0]"})," is that, ",s.exports.jsx(e.code,{children:"x1"})," first decays to a pointer automatically, then the indexing operator defined on ",s.exports.jsx(e.strong,{children:"pointers"})," gets invoked, and then desugar-ed into ",s.exports.jsx(e.code,{children:"*(x1 + 0)"}),". Pointer arithmetic happens behind the scene every time you manipulate an array!"]})]}),`
`,s.exports.jsx(e.h2,{id:"lambdas-and-functional-programming",children:s.exports.jsx(e.a,{href:"#lambdas-and-functional-programming",children:"Lambdas and Functional Programming"})}),`
`,s.exports.jsx(e.p,{children:"Coming soon..."}),`
`,s.exports.jsx(e.h2,{id:"runtime-polymorphism",children:s.exports.jsx(e.a,{href:"#runtime-polymorphism",children:"Runtime Polymorphism"})}),`
`,s.exports.jsx(e.p,{children:"Polymorphism is important in programming: it allows us to abstract over types and write code that works for different types. We already learned one form of polymorphism in lab 1, the generic functions, i.e., parametric polymorphism. The problem with generic functions (aka function templates) is that they only provide compile-time polymorphism, because template instantiation requires information about its type parameters. Note that types are a compile-time construct: the compilation process erases all type information of our program, meaning templates cannot be instantiated at runtime. This implies that we cannot use templates to handle runtime polymorphism, i.e., the polymorphic behavior of some object whose type is determined at runtime. Consider the following example:"}),`
`,s.exports.jsx(e.pre,{className:"language-cpp",children:s.exports.jsxs(e.code,{className:"language-cpp code-highlight",children:[s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-c",children:'// the type of each element in "objects" could be determined by some runtime condition'}),`
`]}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-c",children:"// what should we put in ???"}),`
`]}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-k",children:"auto"})," objects = std::vector<???>{ Rectangle{ .",s.exports.jsx(e.span,{className:"pl-smi",children:"width"})," = ",s.exports.jsx(e.span,{className:"pl-c1",children:"2"})," }, Circle{ .",s.exports.jsx(e.span,{className:"pl-smi",children:"radius"})," = ",s.exports.jsx(e.span,{className:"pl-c1",children:"1"}),` } };
`]})]})}),`
`,s.exports.jsxs(e.p,{children:["The basic idea is that we need to create a ",s.exports.jsx(e.em,{children:"proxy"})," type ",s.exports.jsx(e.code,{children:"T"})," which converts any relevant type to itself, then we can use ",s.exports.jsx(e.code,{children:"T"})," as an interface to deal with different types uniformly as ",s.exports.jsx(e.code,{children:"T"}),". In the above example, ",s.exports.jsx(e.code,{children:"T"})," would be something like a ",s.exports.jsx(e.code,{children:"Shape"}),"."]}),`
`,s.exports.jsx(e.pre,{className:"language-cpp",children:s.exports.jsxs(e.code,{className:"language-cpp code-highlight",children:[s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-c",children:'// any "Rectangle" or "Circle" object, or potentially an object of some other type,'}),`
`]}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-c",children:'// will be converted to an object of type "Shape"'}),`
`]}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-k",children:"auto"})," objects = std::vector<Shape>{ Rectangle{ .",s.exports.jsx(e.span,{className:"pl-smi",children:"width"})," = ",s.exports.jsx(e.span,{className:"pl-c1",children:"2"})," }, Circle{ .",s.exports.jsx(e.span,{className:"pl-smi",children:"radius"})," = ",s.exports.jsx(e.span,{className:"pl-c1",children:"1"}),` } };
`]})]})}),`
`,s.exports.jsxs(e.p,{children:["The remaining question is, how do we define proxy types like ",s.exports.jsx(e.code,{children:"Shape"}),"?"]}),`
`,s.exports.jsx(e.h3,{id:"function-type-proxies",children:s.exports.jsx(e.a,{href:"#function-type-proxies",children:"Function Type Proxies"})}),`
`,s.exports.jsxs(e.p,{children:["The easiest solution is to use ",s.exports.jsx(e.code,{children:"std::function"})," if we only need to deal with ",s.exports.jsx(e.em,{children:"function-like"})," types. Take the lighting computations in ray tracing, for instance: these are all functions that take an intersection position and return (light direction, light color). Therefore, they can be unified by a proxy type as follows:"]}),`
`,s.exports.jsx(e.pre,{className:"language-cpp",children:s.exports.jsxs(e.code,{className:"language-cpp code-highlight",children:[s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-k",children:"namespace"})," ",s.exports.jsx(e.span,{className:"pl-en",children:"Lights"}),` {
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["	",s.exports.jsx(e.span,{className:"pl-c",children:"// Signature: IntersectionPosition -> (LightDirection, LightColor)"}),`
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["	",s.exports.jsx(e.span,{className:"pl-k",children:"using"})," Signature = ",s.exports.jsx(e.span,{className:"pl-k",children:"auto"}),"(",s.exports.jsx(e.span,{className:"pl-k",children:"const"}),` glm::vec4&)->std::tuple<glm::vec4, glm::vec3>;
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["	",s.exports.jsx(e.span,{className:"pl-k",children:"using"}),` Proxy = std::function<Signature>;
`]}),s.exports.jsx(e.span,{className:"code-line",children:`
`}),s.exports.jsxs(e.span,{className:"code-line",children:["	",s.exports.jsx(e.span,{className:"pl-k",children:"auto"})," ",s.exports.jsx(e.span,{className:"pl-en",children:"Point"}),"(",s.exports.jsx(e.span,{className:"pl-k",children:"auto"}),"&& Position, ",s.exports.jsx(e.span,{className:"pl-k",children:"auto"}),"&& Color, ",s.exports.jsx(e.span,{className:"pl-k",children:"auto"}),`&& AttenuationFunction) {
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["		",s.exports.jsx(e.span,{className:"pl-k",children:"return"})," [=](",s.exports.jsx(e.span,{className:"pl-k",children:"auto"}),"&& IntersectionPosition) { ",s.exports.jsx(e.span,{className:"pl-c",children:"/* ... */"}),` };
`]}),s.exports.jsx(e.span,{className:"code-line",children:`	}
`}),s.exports.jsxs(e.span,{className:"code-line",children:["	",s.exports.jsx(e.span,{className:"pl-k",children:"auto"})," ",s.exports.jsx(e.span,{className:"pl-en",children:"Directional"}),"(",s.exports.jsx(e.span,{className:"pl-k",children:"auto"}),"&& Direction, ",s.exports.jsx(e.span,{className:"pl-k",children:"auto"}),`&& Color) {
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["		",s.exports.jsx(e.span,{className:"pl-k",children:"return"})," [=](",s.exports.jsx(e.span,{className:"pl-k",children:"auto"}),"&& IntersectionPosition) { ",s.exports.jsx(e.span,{className:"pl-c",children:"/* ... */"}),` };
`]}),s.exports.jsx(e.span,{className:"code-line",children:`	}
`}),s.exports.jsxs(e.span,{className:"code-line",children:["	",s.exports.jsx(e.span,{className:"pl-k",children:"auto"})," ",s.exports.jsx(e.span,{className:"pl-en",children:"Spot"}),"(",s.exports.jsx(e.span,{className:"pl-k",children:"auto"}),"&& Position, ",s.exports.jsx(e.span,{className:"pl-k",children:"auto"}),"&& Axis, ",s.exports.jsx(e.span,{className:"pl-k",children:"auto"})," Theta, ",s.exports.jsx(e.span,{className:"pl-k",children:"auto"})," Penumbra, ",s.exports.jsx(e.span,{className:"pl-k",children:"auto"}),"&& Color, ",s.exports.jsx(e.span,{className:"pl-k",children:"auto"}),`&& AttenuationFunction) {
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["		",s.exports.jsx(e.span,{className:"pl-k",children:"return"})," [=](",s.exports.jsx(e.span,{className:"pl-k",children:"auto"}),"&& IntersectionPosition) { ",s.exports.jsx(e.span,{className:"pl-c",children:"/* ... */"}),` };
`]}),s.exports.jsx(e.span,{className:"code-line",children:`	}
`}),s.exports.jsx(e.span,{className:"code-line",children:`}
`}),s.exports.jsx(e.span,{className:"code-line",children:`
`}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-k",children:"auto"})," lightSources = std::vector<Lights::Proxy>{ ",s.exports.jsx(e.span,{className:"pl-c1",children:"Lights::Point"}),"(...), ",s.exports.jsx(e.span,{className:"pl-c1",children:"Lights::Directional"}),"(...), ",s.exports.jsx(e.span,{className:"pl-c1",children:"Lights::Spot"}),`(...), ... };
`]}),s.exports.jsx(e.span,{className:"code-line",children:`
`}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-k",children:"for"})," (",s.exports.jsx(e.span,{className:"pl-k",children:"auto"}),`& light : lightSources) {
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["	",s.exports.jsx(e.span,{className:"pl-k",children:"auto"})," [lightDirection, lightColor] = ",s.exports.jsx(e.span,{className:"pl-c1",children:"light"}),`(IntersectionPosition);
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["	",s.exports.jsx(e.span,{className:"pl-c",children:"// do something with lightDirection and lightColor"}),`
`]}),s.exports.jsx(e.span,{className:"code-line",children:`}
`})]})}),`
`,s.exports.jsxs(e.p,{children:[`Non-function proxy types are trickier to define.
There are two mainstream approaches in C++ that allow us to do this: existential types and virtual functions. Both approaches are the same under the hood: we have a `,s.exports.jsx(e.code,{children:"struct"})," of function pointers and a type-erased object. We store the object along with the (pointers to the) functions that handle the type-erased object properly, so the behaviors of the proxy type are dynamically determined at runtime."]}),`
`,s.exports.jsx(e.h3,{id:"existential-types",children:s.exports.jsx(e.a,{href:"#existential-types",children:"Existential Types"})}),`
`,s.exports.jsxs(e.p,{children:['Existential types are the more common approach in modern C++ and offer several advantages over virtual functions (the more common alternative in older C++), which we\u2019ll explain later. The reason for the name "existential" comes from type theory: the fact that the proxy type is an existential quantification over types. The key idea of building an existential type is to have a universally quantified (aka generic) constructor, so it may convert any type to itself. Take the ',s.exports.jsx(e.code,{children:"Shape"})," example we saw above, for instance:"]}),`
`,s.exports.jsx(e.pre,{className:"language-cpp",children:s.exports.jsxs(e.code,{className:"language-cpp code-highlight",children:[s.exports.jsxs(e.span,{className:"code-line",children:["#",s.exports.jsx(e.span,{className:"pl-k",children:"include"})," ",s.exports.jsxs(e.span,{className:"pl-s",children:[s.exports.jsx(e.span,{className:"pl-pds",children:"<"}),"any",s.exports.jsx(e.span,{className:"pl-pds",children:">"})]}),`
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["#",s.exports.jsx(e.span,{className:"pl-k",children:"include"})," ",s.exports.jsxs(e.span,{className:"pl-s",children:[s.exports.jsx(e.span,{className:"pl-pds",children:"<"}),"string",s.exports.jsx(e.span,{className:"pl-pds",children:">"})]}),`
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["#",s.exports.jsx(e.span,{className:"pl-k",children:"include"})," ",s.exports.jsxs(e.span,{className:"pl-s",children:[s.exports.jsx(e.span,{className:"pl-pds",children:"<"}),"vector",s.exports.jsx(e.span,{className:"pl-pds",children:">"})]}),`
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["#",s.exports.jsx(e.span,{className:"pl-k",children:"include"})," ",s.exports.jsxs(e.span,{className:"pl-s",children:[s.exports.jsx(e.span,{className:"pl-pds",children:"<"}),"iostream",s.exports.jsx(e.span,{className:"pl-pds",children:">"})]}),`
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["#",s.exports.jsx(e.span,{className:"pl-k",children:"include"})," ",s.exports.jsxs(e.span,{className:"pl-s",children:[s.exports.jsx(e.span,{className:"pl-pds",children:'"'}),"placeholder.hpp",s.exports.jsx(e.span,{className:"pl-pds",children:'"'})]})," ",s.exports.jsx(e.span,{className:"pl-c",children:"// required for the AnyBut concept"}),`
`]}),s.exports.jsx(e.span,{className:"code-line",children:`
`}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-k",children:"struct"})," ",s.exports.jsx(e.span,{className:"pl-en",children:"Rectangle"}),` {
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["    ",s.exports.jsx(e.span,{className:"pl-k",children:"double"})," length = ",s.exports.jsx(e.span,{className:"pl-c1",children:"1"}),`;
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["    ",s.exports.jsx(e.span,{className:"pl-k",children:"double"})," width = ",s.exports.jsx(e.span,{className:"pl-c1",children:"1"}),`;
`]}),s.exports.jsx(e.span,{className:"code-line",children:`
`}),s.exports.jsxs(e.span,{className:"code-line",children:["    ",s.exports.jsx(e.span,{className:"pl-k",children:"auto"})," ",s.exports.jsx(e.span,{className:"pl-en",children:"toString"}),`() {
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["        ",s.exports.jsx(e.span,{className:"pl-k",children:"return"})," ",s.exports.jsxs(e.span,{className:"pl-s",children:[s.exports.jsx(e.span,{className:"pl-pds",children:'"'}),"Rectangle[length: ",s.exports.jsx(e.span,{className:"pl-pds",children:'"'})]})," + ",s.exports.jsx(e.span,{className:"pl-c1",children:"std::to_string"}),"(length) + ",s.exports.jsxs(e.span,{className:"pl-s",children:[s.exports.jsx(e.span,{className:"pl-pds",children:'"'}),", width: ",s.exports.jsx(e.span,{className:"pl-pds",children:'"'})]})," + ",s.exports.jsx(e.span,{className:"pl-c1",children:"std::to_string"}),"(width) + ",s.exports.jsxs(e.span,{className:"pl-s",children:[s.exports.jsx(e.span,{className:"pl-pds",children:'"'}),"]",s.exports.jsx(e.span,{className:"pl-pds",children:'"'})]}),`;
`]}),s.exports.jsx(e.span,{className:"code-line",children:`    }
`}),s.exports.jsx(e.span,{className:"code-line",children:`};
`}),s.exports.jsx(e.span,{className:"code-line",children:`
`}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-k",children:"struct"})," ",s.exports.jsx(e.span,{className:"pl-en",children:"Circle"}),` {
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["    ",s.exports.jsx(e.span,{className:"pl-k",children:"double"})," radius = ",s.exports.jsx(e.span,{className:"pl-c1",children:"1"}),`;
`]}),s.exports.jsx(e.span,{className:"code-line",children:`
`}),s.exports.jsxs(e.span,{className:"code-line",children:["    ",s.exports.jsx(e.span,{className:"pl-k",children:"auto"})," ",s.exports.jsx(e.span,{className:"pl-en",children:"toString"}),`() {
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["        ",s.exports.jsx(e.span,{className:"pl-k",children:"return"})," ",s.exports.jsxs(e.span,{className:"pl-s",children:[s.exports.jsx(e.span,{className:"pl-pds",children:'"'}),"Circle[radius: ",s.exports.jsx(e.span,{className:"pl-pds",children:'"'})]})," + ",s.exports.jsx(e.span,{className:"pl-c1",children:"std::to_string"}),"(radius) + ",s.exports.jsxs(e.span,{className:"pl-s",children:[s.exports.jsx(e.span,{className:"pl-pds",children:'"'}),"]",s.exports.jsx(e.span,{className:"pl-pds",children:'"'})]}),`;
`]}),s.exports.jsx(e.span,{className:"code-line",children:`    }
`}),s.exports.jsx(e.span,{className:"code-line",children:`};
`}),s.exports.jsx(e.span,{className:"code-line",children:`
`}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-k",children:"struct"})," ",s.exports.jsx(e.span,{className:"pl-en",children:"Shape"}),` {
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["    ",s.exports.jsx(e.span,{className:"pl-k",children:"using"})," ToStringSignature = ",s.exports.jsx(e.span,{className:"pl-k",children:"auto"}),`(std::any&)->std::string;
`]}),s.exports.jsx(e.span,{className:"code-line",children:`
`}),s.exports.jsx(e.span,{className:"code-line",children:`    std::any object = {};
`}),s.exports.jsxs(e.span,{className:"code-line",children:["    ToStringSignature* toStringFunction = ",s.exports.jsx(e.span,{className:"pl-c1",children:"nullptr"}),`;
`]}),s.exports.jsx(e.span,{className:"code-line",children:`
`}),s.exports.jsxs(e.span,{className:"code-line",children:["    ",s.exports.jsx(e.span,{className:"pl-en",children:"Shape"}),"() = ",s.exports.jsx(e.span,{className:"pl-k",children:"default"}),`;
`]}),s.exports.jsx(e.span,{className:"code-line",children:`
`}),s.exports.jsxs(e.span,{className:"code-line",children:["    ",s.exports.jsx(e.span,{className:"pl-c",children:'// exclude "Shape" itself from the universal quantification'}),`
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["    ",s.exports.jsx(e.span,{className:"pl-c",children:"// to avoid conflict with the copy/move constructors"}),`
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["    ",s.exports.jsx(e.span,{className:"pl-en",children:"Shape"}),"(AnyBut<Shape> ",s.exports.jsx(e.span,{className:"pl-k",children:"auto"}),`&& x) {
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["        ",s.exports.jsx(e.span,{className:"pl-k",children:"using"})," ObjectType = std::",s.exports.jsx(e.span,{className:"pl-c1",children:"decay_t"}),"<",s.exports.jsx(e.span,{className:"pl-c1",children:"decltype"}),`(x)>;
`]}),s.exports.jsx(e.span,{className:"code-line",children:`
`}),s.exports.jsxs(e.span,{className:"code-line",children:["        ",s.exports.jsx(e.span,{className:"pl-c1",children:"this"}),"->",s.exports.jsx(e.span,{className:"pl-smi",children:"object"})," = std::forward<",s.exports.jsx(e.span,{className:"pl-c1",children:"decltype"}),`(x)>(x);
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["        ",s.exports.jsx(e.span,{className:"pl-c1",children:"this"}),"->",s.exports.jsx(e.span,{className:"pl-smi",children:"toStringFunction"})," = [](",s.exports.jsx(e.span,{className:"pl-k",children:"auto"}),"& object) { ",s.exports.jsx(e.span,{className:"pl-k",children:"return"})," std::any_cast<ObjectType&>(object).",s.exports.jsx(e.span,{className:"pl-c1",children:"toString"}),`(); };
`]}),s.exports.jsx(e.span,{className:"code-line",children:`    }
`}),s.exports.jsx(e.span,{className:"code-line",children:`
`}),s.exports.jsxs(e.span,{className:"code-line",children:["    ",s.exports.jsx(e.span,{className:"pl-k",children:"auto"})," ",s.exports.jsx(e.span,{className:"pl-en",children:"toString"}),`() {
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["        ",s.exports.jsx(e.span,{className:"pl-k",children:"return"})," ",s.exports.jsx(e.span,{className:"pl-c1",children:"toStringFunction"}),`(object);
`]}),s.exports.jsx(e.span,{className:"code-line",children:`    }
`}),s.exports.jsx(e.span,{className:"code-line",children:`};
`}),s.exports.jsx(e.span,{className:"code-line",children:`
`}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-k",children:"auto"})," ",s.exports.jsx(e.span,{className:"pl-en",children:"main"}),`()->int {
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["    ",s.exports.jsx(e.span,{className:"pl-k",children:"auto"})," objects = std::vector<Shape>{ Rectangle{ .",s.exports.jsx(e.span,{className:"pl-smi",children:"width"})," = ",s.exports.jsx(e.span,{className:"pl-c1",children:"2"})," }, Circle{ .",s.exports.jsx(e.span,{className:"pl-smi",children:"radius"})," = ",s.exports.jsx(e.span,{className:"pl-c1",children:"1"}),` } };
`]}),s.exports.jsx(e.span,{className:"code-line",children:`
`}),s.exports.jsxs(e.span,{className:"code-line",children:["    ",s.exports.jsx(e.span,{className:"pl-k",children:"for"})," (",s.exports.jsx(e.span,{className:"pl-k",children:"auto"}),`& x : objects)
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["        std::cout << x.",s.exports.jsx(e.span,{className:"pl-c1",children:"toString"}),`() << std::endl;
`]}),s.exports.jsx(e.span,{className:"code-line",children:`
`}),s.exports.jsxs(e.span,{className:"code-line",children:["    ",s.exports.jsx(e.span,{className:"pl-c",children:"// you should see that it prints:"}),`
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["    ",s.exports.jsx(e.span,{className:"pl-c",children:"// Rectangle[length: 1.000000, width: 2.000000]"}),`
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["    ",s.exports.jsx(e.span,{className:"pl-c",children:"// Circle[radius: 1.000000]"}),`
`]}),s.exports.jsx(e.span,{className:"code-line",children:`}
`})]})}),`
`,s.exports.jsx(e.h3,{id:"virtual-functions",children:s.exports.jsx(e.a,{href:"#virtual-functions",children:"Virtual Functions"})}),`
`,s.exports.jsxs(e.p,{children:[`Virtual functions are the traditional way to achieve runtime polymorphism in C++: they've been around since the creation of language and don't require any newer language features (such as the concepts required by existential types).
Their main advantage over existential types is that they're easier to define (there's built-in language support for them), and they map nicely onto object-oriented design patterns that you're probably already familiar with.
They do have some disadvantages, though.
Any type with at least one virtual function no longer has a standard memory layout, meaning objects of such types cannot be `,s.exports.jsx(e.code,{children:"memcpy"}),`-ed.
As a consequence, such types cannot be allocated on the stack: every object of such a type must be dynamically allocated and accessed through a pointer.
You must then use smart pointers or manually manage the lifetime of each object very carefully.
Virtual functions, like classic object-oriented programming, also require restrictive, top-down program design: you must design the abstract parent type first, and then design concrete child types that inherit from it.
In contrast, existential types allow you to define concrete types as needed, and then later add an abstract proxy type for them if needed.`]}),`
`,s.exports.jsxs(e.p,{children:["The same ",s.exports.jsx(e.code,{children:"Shape"})," example written in a virtual function-based design would be as follows:"]}),`
`,s.exports.jsx(e.pre,{className:"language-cpp",children:s.exports.jsxs(e.code,{className:"language-cpp code-highlight",children:[s.exports.jsxs(e.span,{className:"code-line",children:["#",s.exports.jsx(e.span,{className:"pl-k",children:"include"})," ",s.exports.jsxs(e.span,{className:"pl-s",children:[s.exports.jsx(e.span,{className:"pl-pds",children:"<"}),"string",s.exports.jsx(e.span,{className:"pl-pds",children:">"})]}),`
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["#",s.exports.jsx(e.span,{className:"pl-k",children:"include"})," ",s.exports.jsxs(e.span,{className:"pl-s",children:[s.exports.jsx(e.span,{className:"pl-pds",children:"<"}),"vector",s.exports.jsx(e.span,{className:"pl-pds",children:">"})]}),`
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["#",s.exports.jsx(e.span,{className:"pl-k",children:"include"})," ",s.exports.jsxs(e.span,{className:"pl-s",children:[s.exports.jsx(e.span,{className:"pl-pds",children:"<"}),"iostream",s.exports.jsx(e.span,{className:"pl-pds",children:">"})]}),`
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["#",s.exports.jsx(e.span,{className:"pl-k",children:"include"})," ",s.exports.jsxs(e.span,{className:"pl-s",children:[s.exports.jsx(e.span,{className:"pl-pds",children:"<"}),"memory",s.exports.jsx(e.span,{className:"pl-pds",children:">"})]}),`
`]}),s.exports.jsx(e.span,{className:"code-line",children:`
`}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-c",children:'// "class" is more conventional for virtual function based designs'}),`
`]}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-k",children:"class"})," ",s.exports.jsx(e.span,{className:"pl-en",children:"Shape"}),` {
`]}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-k",children:"public:"}),`
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["    ",s.exports.jsx(e.span,{className:"pl-k",children:"virtual"})," ",s.exports.jsx(e.span,{className:"pl-k",children:"auto"})," ",s.exports.jsx(e.span,{className:"pl-en",children:"toString"}),`()->std::string = 0;
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["    ",s.exports.jsx(e.span,{className:"pl-c",children:"// destructors must always be virtual if you decide to use virtual functions"}),`
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["    ",s.exports.jsx(e.span,{className:"pl-k",children:"virtual"})," ",s.exports.jsx(e.span,{className:"pl-en",children:"~Shape"}),"() = ",s.exports.jsx(e.span,{className:"pl-k",children:"default"}),`;
`]}),s.exports.jsx(e.span,{className:"code-line",children:`};
`}),s.exports.jsx(e.span,{className:"code-line",children:`
`}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-c",children:"// concrete types must declare which interfaces they will implement"}),`
`]}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-c",children:"// you cannot do this afterwards like existential types"}),`
`]}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-k",children:"class"})," ",s.exports.jsx(e.span,{className:"pl-en",children:"Rectangle"})," ",s.exports.jsx(e.span,{className:"pl-k",children:"final"}),`: public Shape {
`]}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-k",children:"public:"}),`
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["    ",s.exports.jsx(e.span,{className:"pl-k",children:"double"})," length = ",s.exports.jsx(e.span,{className:"pl-c1",children:"1"}),`;
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["    ",s.exports.jsx(e.span,{className:"pl-k",children:"double"})," width = ",s.exports.jsx(e.span,{className:"pl-c1",children:"1"}),`;
`]}),s.exports.jsx(e.span,{className:"code-line",children:`
`}),s.exports.jsxs(e.span,{className:"code-line",children:["    ",s.exports.jsx(e.span,{className:"pl-c",children:"// must manually define constructors and the destructor"}),`
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["    ",s.exports.jsx(e.span,{className:"pl-c",children:"// because virtual functions disqualify aggregate initialization"}),`
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["    ",s.exports.jsx(e.span,{className:"pl-en",children:"Rectangle"}),"() = ",s.exports.jsx(e.span,{className:"pl-k",children:"default"}),`;
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["    ",s.exports.jsx(e.span,{className:"pl-en",children:"Rectangle"}),"(",s.exports.jsx(e.span,{className:"pl-k",children:"double"})," _length, ",s.exports.jsx(e.span,{className:"pl-k",children:"double"}),` _width): length{ _length }, width{ _width } {}
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["    ",s.exports.jsx(e.span,{className:"pl-en",children:"~Rectangle"}),"() ",s.exports.jsx(e.span,{className:"pl-k",children:"override"})," = ",s.exports.jsx(e.span,{className:"pl-k",children:"default"}),`;
`]}),s.exports.jsx(e.span,{className:"code-line",children:`
`}),s.exports.jsxs(e.span,{className:"code-line",children:["    ",s.exports.jsx(e.span,{className:"pl-k",children:"auto"})," ",s.exports.jsx(e.span,{className:"pl-en",children:"toString"}),"()->std::string ",s.exports.jsx(e.span,{className:"pl-k",children:"override"}),` {
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["        ",s.exports.jsx(e.span,{className:"pl-k",children:"return"})," ",s.exports.jsxs(e.span,{className:"pl-s",children:[s.exports.jsx(e.span,{className:"pl-pds",children:'"'}),"Rectangle[length: ",s.exports.jsx(e.span,{className:"pl-pds",children:'"'})]})," + ",s.exports.jsx(e.span,{className:"pl-c1",children:"std::to_string"}),"(length) + ",s.exports.jsxs(e.span,{className:"pl-s",children:[s.exports.jsx(e.span,{className:"pl-pds",children:'"'}),", width: ",s.exports.jsx(e.span,{className:"pl-pds",children:'"'})]})," + ",s.exports.jsx(e.span,{className:"pl-c1",children:"std::to_string"}),"(width) + ",s.exports.jsxs(e.span,{className:"pl-s",children:[s.exports.jsx(e.span,{className:"pl-pds",children:'"'}),"]",s.exports.jsx(e.span,{className:"pl-pds",children:'"'})]}),`;
`]}),s.exports.jsx(e.span,{className:"code-line",children:`    }
`}),s.exports.jsx(e.span,{className:"code-line",children:`};
`}),s.exports.jsx(e.span,{className:"code-line",children:`
`}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-k",children:"class"})," ",s.exports.jsx(e.span,{className:"pl-en",children:"Circle"})," ",s.exports.jsx(e.span,{className:"pl-k",children:"final"}),`: public Shape {
`]}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-k",children:"public:"}),`
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["    ",s.exports.jsx(e.span,{className:"pl-k",children:"double"})," radius = ",s.exports.jsx(e.span,{className:"pl-c1",children:"1"}),`;
`]}),s.exports.jsx(e.span,{className:"code-line",children:`
`}),s.exports.jsxs(e.span,{className:"code-line",children:["    ",s.exports.jsx(e.span,{className:"pl-en",children:"Circle"}),"() = ",s.exports.jsx(e.span,{className:"pl-k",children:"default"}),`;
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["    ",s.exports.jsx(e.span,{className:"pl-en",children:"Circle"}),"(",s.exports.jsx(e.span,{className:"pl-k",children:"double"}),` _radius): radius{ _radius } {}
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["    ",s.exports.jsx(e.span,{className:"pl-en",children:"~Circle"}),"() ",s.exports.jsx(e.span,{className:"pl-k",children:"override"})," = ",s.exports.jsx(e.span,{className:"pl-k",children:"default"}),`;
`]}),s.exports.jsx(e.span,{className:"code-line",children:`
`}),s.exports.jsxs(e.span,{className:"code-line",children:["    ",s.exports.jsx(e.span,{className:"pl-k",children:"auto"})," ",s.exports.jsx(e.span,{className:"pl-en",children:"toString"}),"()->std::string ",s.exports.jsx(e.span,{className:"pl-k",children:"override"}),` {
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["        ",s.exports.jsx(e.span,{className:"pl-k",children:"return"})," ",s.exports.jsxs(e.span,{className:"pl-s",children:[s.exports.jsx(e.span,{className:"pl-pds",children:'"'}),"Circle[radius: ",s.exports.jsx(e.span,{className:"pl-pds",children:'"'})]})," + ",s.exports.jsx(e.span,{className:"pl-c1",children:"std::to_string"}),"(radius) + ",s.exports.jsxs(e.span,{className:"pl-s",children:[s.exports.jsx(e.span,{className:"pl-pds",children:'"'}),"]",s.exports.jsx(e.span,{className:"pl-pds",children:'"'})]}),`;
`]}),s.exports.jsx(e.span,{className:"code-line",children:`    }
`}),s.exports.jsx(e.span,{className:"code-line",children:`};
`}),s.exports.jsx(e.span,{className:"code-line",children:`
`}),s.exports.jsxs(e.span,{className:"code-line",children:[s.exports.jsx(e.span,{className:"pl-k",children:"auto"})," ",s.exports.jsx(e.span,{className:"pl-en",children:"main"}),`()->int {
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["    ",s.exports.jsx(e.span,{className:"pl-c",children:'// a vector of "Shape"s is not allowed; you can only have a vector of pointers to Shapes'}),`
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["    ",s.exports.jsx(e.span,{className:"pl-k",children:"auto"}),` objects = std::vector<std::unique_ptr<Shape>>{};
`]}),s.exports.jsx(e.span,{className:"code-line",children:`
`}),s.exports.jsxs(e.span,{className:"code-line",children:["    objects.",s.exports.jsx(e.span,{className:"pl-c1",children:"emplace_back"}),"(",s.exports.jsx(e.span,{className:"pl-k",children:"new"})," Rectangle{ ",s.exports.jsx(e.span,{className:"pl-c1",children:"1"}),", ",s.exports.jsx(e.span,{className:"pl-c1",children:"2"}),` });
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["    objects.",s.exports.jsx(e.span,{className:"pl-c1",children:"emplace_back"}),"(",s.exports.jsx(e.span,{className:"pl-k",children:"new"})," Circle{ ",s.exports.jsx(e.span,{className:"pl-c1",children:"1"}),` });
`]}),s.exports.jsx(e.span,{className:"code-line",children:`
`}),s.exports.jsxs(e.span,{className:"code-line",children:["    ",s.exports.jsx(e.span,{className:"pl-k",children:"for"})," (",s.exports.jsx(e.span,{className:"pl-k",children:"auto"}),`& x : objects)
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["        std::cout << x->",s.exports.jsx(e.span,{className:"pl-c1",children:"toString"}),`() << std::endl;
`]}),s.exports.jsx(e.span,{className:"code-line",children:`
`}),s.exports.jsxs(e.span,{className:"code-line",children:["    ",s.exports.jsx(e.span,{className:"pl-c",children:"// you should see that it prints:"}),`
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["    ",s.exports.jsx(e.span,{className:"pl-c",children:"// Rectangle[length: 1.000000, width: 2.000000]"}),`
`]}),s.exports.jsxs(e.span,{className:"code-line",children:["    ",s.exports.jsx(e.span,{className:"pl-c",children:"// Circle[radius: 1.000000]"}),`
`]}),s.exports.jsx(e.span,{className:"code-line",children:`}
`})]})}),`
`,s.exports.jsx(l,{})]})]})}function t(a={}){const{wrapper:e}=a.components||{};return e?s.exports.jsx(e,Object.assign({},a,{children:s.exports.jsx(n,a)})):n(a)}export{t as default,p as documentProps};
