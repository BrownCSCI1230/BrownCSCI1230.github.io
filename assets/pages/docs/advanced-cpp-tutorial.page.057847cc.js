import{j as e}from"../../chunk-903e764a.js";import{M as l}from"../../chunk-b2e2a089.js";const t={title:"Advanced C++ Tutorial"};function a(n){const s=Object.assign({nav:"nav",ol:"ol",li:"li",a:"a",main:"main",h1:"h1",p:"p",h2:"h2",pre:"pre",code:"code",span:"span",em:"em",strong:"strong"},n.components);return e.exports.jsxs(e.exports.Fragment,{children:[e.exports.jsx(s.nav,{className:"toc",children:e.exports.jsx(s.ol,{className:"toc-level toc-level-1",children:e.exports.jsxs(s.li,{className:"toc-item toc-item-h1",children:[e.exports.jsx(s.a,{className:"toc-link toc-link-h1",href:"#advanced-c-tutorial",children:"Advanced C++ Tutorial"}),e.exports.jsxs(s.ol,{className:"toc-level toc-level-2",children:[e.exports.jsx(s.li,{className:"toc-item toc-item-h2",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h2",href:"#dynamic-memory-allocation-raii-and-smart-pointers",children:"Dynamic Memory Allocation, RAII and Smart Pointers"})}),e.exports.jsx(s.li,{className:"toc-item toc-item-h2",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h2",href:"#operator-overloading-and-user-defined-literals",children:"Operator Overloading and User Defined Literals"})}),e.exports.jsx(s.li,{className:"toc-item toc-item-h2",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h2",href:"#lambdas-and-functional-programming",children:"Lambdas and Functional Programming"})}),e.exports.jsx(s.li,{className:"toc-item toc-item-h2",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h2",href:"#pointers-and-references-reprise",children:"Pointers and References (Reprise)"})}),e.exports.jsx(s.li,{className:"toc-item toc-item-h2",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h2",href:"#pointer-arithmetic",children:"Pointer Arithmetic"})}),e.exports.jsx(s.li,{className:"toc-item toc-item-h2",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h2",href:"#runtime-polymorphism-and-existential-types",children:"Runtime Polymorphism and Existential Types"})})]})]})})}),e.exports.jsxs(s.main,{children:[`
`,`
`,e.exports.jsx(s.h1,{id:"advanced-c-tutorial",children:e.exports.jsx(s.a,{href:"#advanced-c-tutorial",children:"Advanced C++ Tutorial"})}),`
`,e.exports.jsx(s.p,{children:`In lab 1, we introduced you to the minimum C++ features you'll need for programming work in this course.
In this lab, we'll talk about additional C++ features you can use to improve your program design. We'll also cover things happening under the hood for you to have a deeper understanding of the language in general.`}),`
`,e.exports.jsx(s.h2,{id:"dynamic-memory-allocation-raii-and-smart-pointers",children:e.exports.jsx(s.a,{href:"#dynamic-memory-allocation-raii-and-smart-pointers",children:"Dynamic Memory Allocation, RAII and Smart Pointers"})}),`
`,e.exports.jsx(s.p,{children:"placeholder"}),`
`,e.exports.jsx(s.h2,{id:"operator-overloading-and-user-defined-literals",children:e.exports.jsx(s.a,{href:"#operator-overloading-and-user-defined-literals",children:"Operator Overloading and User Defined Literals"})}),`
`,e.exports.jsx(s.p,{children:"placeholder"}),`
`,e.exports.jsx(s.h2,{id:"lambdas-and-functional-programming",children:e.exports.jsx(s.a,{href:"#lambdas-and-functional-programming",children:"Lambdas and Functional Programming"})}),`
`,e.exports.jsx(s.p,{children:"placeholder"}),`
`,e.exports.jsx(s.h2,{id:"pointers-and-references-reprise",children:e.exports.jsx(s.a,{href:"#pointers-and-references-reprise",children:"Pointers and References (Reprise)"})}),`
`,e.exports.jsx(s.p,{children:"In lab 1, we mentioned that we can access the entity that a pointer points to by dereferencing the pointer, and that a reference represents an entity at a particular memory address. It seems that there should be a connection between pointers and references, indeed, we obtain a reference when we dereference a pointer:"}),`
`,e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," x = ",e.exports.jsx(s.span,{className:"pl-c1",children:"42"}),`;
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," y = Rectangle{ .",e.exports.jsx(s.span,{className:"pl-smi",children:"length"})," = ",e.exports.jsx(s.span,{className:"pl-c1",children:"4"}),", .",e.exports.jsx(s.span,{className:"pl-smi",children:"width"})," = ",e.exports.jsx(s.span,{className:"pl-c1",children:"2"}),` };
`]}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),` px = &x;
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),` py = &y;
`]}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),"& refx = *px; ",e.exports.jsx(s.span,{className:"pl-c",children:'// same as "auto& refx = x;"'}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),"& yLength = py->length; ",e.exports.jsx(s.span,{className:"pl-c",children:'// same as "auto& yLength = y.length;"'}),`
`]}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-c",children:"// we can verify that dereferencing a pointer indeed gives us a reference"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-en",children:"static_assert"}),`(std::same_as<decltype(*px), int&>);
`]})]})}),`
`,e.exports.jsx(s.p,{children:"This is precisely the reason why dereferencing a pointer allows us to modify the object it points to, the same way as how we modify something via a reference."}),`
`,e.exports.jsxs(s.p,{children:["One problem with the basic form of references we've learned so far, is that they cannot bind to ",e.exports.jsx(s.em,{children:"values"})," (",e.exports.jsx(s.a,{href:"https://en.cppreference.com/w/cpp/language/value_category#rvalue",target:"_blank",rel:"noopener noreferrer",children:"rvalue"})," in C++ terminology). The reason is obvious, values such as ",e.exports.jsx(s.code,{children:"123"})," or ",e.exports.jsx(s.code,{children:"3.14"})," do not have a memory address because they are not stored in memory by some variable. The same applies to function parameters, we cannot pass values to reference parameters."]}),`
`,e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"func"}),"(std::vector<",e.exports.jsx(s.span,{className:"pl-k",children:"int"}),`>& things)->void {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-c",children:"// empty"}),`
`]}),e.exports.jsx(s.span,{className:"code-line",children:`}
`}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," x = ",e.exports.jsx(s.span,{className:"pl-c1",children:"42"}),`;
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," things = std::vector{ ",e.exports.jsx(s.span,{className:"pl-c1",children:"1"}),", ",e.exports.jsx(s.span,{className:"pl-c1",children:"2"}),", ",e.exports.jsx(s.span,{className:"pl-c1",children:"3"}),", ",e.exports.jsx(s.span,{className:"pl-c1",children:"4"}),` };
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),"& refx = x; ",e.exports.jsx(s.span,{className:"pl-c",children:"// OK, bind to a variable"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-c",children:"// auto& incorrectRef = 42; // error, (lvalue) reference cannot bind to (r)value"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-en",children:"func"}),"(things); ",e.exports.jsx(s.span,{className:"pl-c",children:"// OK, reference parameter binds to 'things'"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-c",children:"// func(std::vector{ 1, 2, 3, 4 }); // error, (lvalue) reference parameter cannot bind to (r)value"}),`
`]})]})}),`
`,e.exports.jsxs(s.p,{children:["This can be inconvenient in some cases. Ideally, we'd want something that behaves like a reference when we bind it to a variable, and like a new variable when we provide it a value. Luckily, we do have something exactly like this in C++ called ",e.exports.jsx(s.em,{children:"forwarding"})," ",e.exports.jsx(s.em,{children:"references"})," in the form of ",e.exports.jsx(s.code,{children:"auto&&"}),"."]}),`
`,e.exports.jsxs("details",{children:[e.exports.jsx("summary",{children:"Be careful though"}),e.exports.jsxs(s.p,{children:[e.exports.jsx(s.code,{children:"&&"})," after a concrete type, like ",e.exports.jsx(s.code,{children:"int&&"})," or ",e.exports.jsx(s.code,{children:"std::vector<int>&&"}),", does not form a forwarding reference! These are ",e.exports.jsx(s.em,{children:"rvalue references"})," which are outside the scope of this doc. You can learn more about rvalue references ",e.exports.jsx(s.a,{href:"https://en.cppreference.com/w/cpp/language/reference#Rvalue_references",target:"_blank",rel:"noopener noreferrer",children:"here"}),", if you're interested."]})]}),`
`,e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"betterFunc"}),"(",e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),`&& things)->void {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["  ",e.exports.jsx(s.span,{className:"pl-c",children:"// empty"}),`
`]}),e.exports.jsx(s.span,{className:"code-line",children:`}
`}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," x = ",e.exports.jsx(s.span,{className:"pl-c1",children:"42"}),`;
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," things = std::vector{ ",e.exports.jsx(s.span,{className:"pl-c1",children:"1"}),", ",e.exports.jsx(s.span,{className:"pl-c1",children:"2"}),", ",e.exports.jsx(s.span,{className:"pl-c1",children:"3"}),", ",e.exports.jsx(s.span,{className:"pl-c1",children:"4"}),` };
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),"&& refx = x; ",e.exports.jsx(s.span,{className:"pl-c",children:"// OK, bind to a variable, same as 'auto& refx = x;'"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),"&& forwardRef = ",e.exports.jsx(s.span,{className:"pl-c1",children:"42"}),"; ",e.exports.jsx(s.span,{className:"pl-c",children:"// OK, creates a new variable as if 'auto forwardRef = 42;'"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-en",children:"betterFunc"}),"(things); ",e.exports.jsx(s.span,{className:"pl-c",children:"// OK, reference parameter binds to 'things'"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-en",children:"betterFunc"}),"(std::vector{ ",e.exports.jsx(s.span,{className:"pl-c1",children:"1"}),", ",e.exports.jsx(s.span,{className:"pl-c1",children:"2"}),", ",e.exports.jsx(s.span,{className:"pl-c1",children:"3"}),", ",e.exports.jsx(s.span,{className:"pl-c1",children:"4"})," }); ",e.exports.jsx(s.span,{className:"pl-c",children:"// OK, as if the parameter type is non-reference"}),`
`]})]})}),`
`,e.exports.jsx(s.h2,{id:"pointer-arithmetic",children:e.exports.jsx(s.a,{href:"#pointer-arithmetic",children:"Pointer Arithmetic"})}),`
`,e.exports.jsx(s.p,{children:"We've discussed in lab 1 that a pointer is an integer storing a memory address. What will happen though, if we perform integer arithmetics on pointers? Consider the following example"}),`
`,e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," p = ",e.exports.jsx(s.span,{className:"pl-k",children:"reinterpret_cast"}),"<",e.exports.jsx(s.span,{className:"pl-k",children:"int"}),"*>(",e.exports.jsx(s.span,{className:"pl-c1",children:"42"}),"); ",e.exports.jsx(s.span,{className:"pl-c",children:"// cast some random integer to a pointer"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["p += ",e.exports.jsx(s.span,{className:"pl-c1",children:"1"}),`;
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," x = ",e.exports.jsx(s.span,{className:"pl-k",children:"reinterpret_cast"}),"<",e.exports.jsx(s.span,{className:"pl-k",children:"unsigned"})," ",e.exports.jsx(s.span,{className:"pl-k",children:"long"})," ",e.exports.jsx(s.span,{className:"pl-k",children:"long"}),">(p); ",e.exports.jsx(s.span,{className:"pl-c",children:"// cast pointer back to integer"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["std::cout << x; ",e.exports.jsx(s.span,{className:"pl-c",children:"// what will you see here?"}),`
`]})]})}),`
`,e.exports.jsxs(s.p,{children:["You would probably think ",e.exports.jsx(s.code,{children:"x"})," is ",e.exports.jsx(s.code,{children:"43"}),", however depending on your hardware platform, you're likely to see ",e.exports.jsx(s.code,{children:"46"}),"! Why is that?"]}),`
`,e.exports.jsxs(s.p,{children:["This is because pointer arithmetic has array semantics, meaning if you have a pointer ",e.exports.jsx(s.code,{children:"p"})," pointing to the address of some object of type ",e.exports.jsx(s.code,{children:"T"}),", ",e.exports.jsx(s.code,{children:"p + n"})," assumes that there is an array of ",e.exports.jsx(s.code,{children:"T"}),"s stored in contiguous memory, and ",e.exports.jsx(s.code,{children:"p + n"})," evaluates to the address of the ",e.exports.jsx(s.code,{children:"n"}),"-th object after the object that ",e.exports.jsx(s.code,{children:"p"})," points to. In the above example, ",e.exports.jsx(s.code,{children:"x"})," contains the address of a (hypothetical) integer next to the (hypotetical) integer whose address is ",e.exports.jsx(s.code,{children:"42"}),". And therefore the value of ",e.exports.jsx(s.code,{children:"x"})," would be ",e.exports.jsx(s.code,{children:"42 + sizeof(int)"}),", since ",e.exports.jsx(s.code,{children:"sizeof(int)"})," is likely ",e.exports.jsx(s.code,{children:"4"})," on most common hardware platforms, you see ",e.exports.jsx(s.code,{children:"46"})," when you print out ",e.exports.jsx(s.code,{children:"x"}),"."]}),`
`,e.exports.jsxs(s.p,{children:[e.exports.jsx(s.code,{children:"n"})," can also be a negative integer in ",e.exports.jsx(s.code,{children:"p + n"}),", let ",e.exports.jsx(s.code,{children:"m = -n"}),", ",e.exports.jsx(s.code,{children:"p + n"})," would be the same as ",e.exports.jsx(s.code,{children:"p - m"}),", meaning the address of the ",e.exports.jsx(s.code,{children:"m"}),"-th object before ",e.exports.jsx(s.code,{children:"*p"}),"."]}),`
`,e.exports.jsxs(s.p,{children:["Pointer arithmetic is common in C/C++, and ",e.exports.jsx(s.code,{children:"*(p + n)"})," is unwieldy, the language therefore defines a syntactic sugar for us to do the exact same thing, we may use the indexing operator ",e.exports.jsx(s.code,{children:"p[n]"})," to represent ",e.exports.jsx(s.code,{children:"*(p + n)"}),", the indexing operator syntax is the exact same as explicit pointer arithmetic."]}),`
`,e.exports.jsxs("details",{children:[e.exports.jsx("summary",{children:"Secrets behind C arrays"}),e.exports.jsxs(s.p,{children:["If you have prior experience in C/C++, you may have noticed that we always use ",e.exports.jsx(s.code,{children:"std::array<T, N>"})," instead of the C array ",e.exports.jsx(s.code,{children:"T[N]"}),". C arrays behave just like a pointer in many cases, and we concluded that this is unnecessary complexity for beginners."]}),e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"int"})," x1[",e.exports.jsx(s.span,{className:"pl-c1",children:"3"}),`];
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," x2 = std::array<",e.exports.jsx(s.span,{className:"pl-k",children:"int"}),", ",e.exports.jsx(s.span,{className:"pl-c1",children:"3"}),`>{};
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," y1 = x1; ",e.exports.jsx(s.span,{className:"pl-c",children:"// this is a pointer! not a copy of the 'x1' array!"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," y2 = x2; ",e.exports.jsx(s.span,{className:"pl-c",children:"// this is a copy of the 'x2' array!"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["y1[",e.exports.jsx(s.span,{className:"pl-c1",children:"0"}),"] = ",e.exports.jsx(s.span,{className:"pl-c1",children:"42"}),"; ",e.exports.jsx(s.span,{className:"pl-c",children:"// this is the same as 'x1[0] = 42'"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["y2[",e.exports.jsx(s.span,{className:"pl-c1",children:"0"}),"] = ",e.exports.jsx(s.span,{className:"pl-c1",children:"42"}),"; ",e.exports.jsx(s.span,{className:"pl-c",children:"// this does nothing to x2, since it's a copy"}),`
`]})]})}),e.exports.jsxs(s.p,{children:["The reason behind this oddity is that C arrays automatically decay to the pointer to its first element. Interestingly, the C++ standard only defines the builtin indexing operator on pointers, it is never said that (C) arrays can be indexed. What happens when the compiler sees ",e.exports.jsx(s.code,{children:"x1[0]"})," is that, ",e.exports.jsx(s.code,{children:"x1"})," first decays to a pointer automatically, then the indexing operator defined on ",e.exports.jsx(s.strong,{children:"pointers"})," gets invoked, and then desugar-ed into ",e.exports.jsx(s.code,{children:"*(x1 + 0)"}),". Pointer arithmetic happens behind the scene every time you manipulate an array!"]})]}),`
`,e.exports.jsx(s.h2,{id:"runtime-polymorphism-and-existential-types",children:e.exports.jsx(s.a,{href:"#runtime-polymorphism-and-existential-types",children:"Runtime Polymorphism and Existential Types"})}),`
`,e.exports.jsxs(s.p,{children:["Polymorphism is important in programming; it allows us to abstract over types and write code that works for different types. We already learned one form of polymorphism in lab 1, the generic functions, i.e., parametric polymorphism. These are functions that work on ",e.exports.jsx(s.em,{children:"any"})," type, and therefore it implies a universal quantification (\u2200) on types."]}),`
`,e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-c",children:"// \u2200 type T, identity takes something of type T, and returns something of type T"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"identity"}),"(",e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),` x) {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"return"}),` x;
`]}),e.exports.jsx(s.span,{className:"code-line",children:`}
`})]})}),`
`,e.exports.jsxs(s.p,{children:["A universally quantified type may convert to any type, e.g., ",e.exports.jsx(s.code,{children:"T"})," converts to ",e.exports.jsx(s.code,{children:"int"})," when we call ",e.exports.jsx(s.code,{children:"identity(42)"}),", and ",e.exports.jsx(s.code,{children:"T"})," becomes ",e.exports.jsx(s.code,{children:"double"})," when we call ",e.exports.jsx(s.code,{children:"identity(3.14)"}),". It always introduces a type parameter representing the type it converts to (hence the name ",e.exports.jsx(s.em,{children:"parametric"})," polymorphism). This can be a problem because sometimes we want polymorphic behaviors without introducing additional type parameters, consider the following example:"]}),`
`,e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-c",children:"// what should we put in ???"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," objects = std::vector<???>{ Rectangle{ .",e.exports.jsx(s.span,{className:"pl-smi",children:"width"})," = ",e.exports.jsx(s.span,{className:"pl-c1",children:"2"})," }, Circle{ .",e.exports.jsx(s.span,{className:"pl-smi",children:"radius"})," = ",e.exports.jsx(s.span,{className:"pl-c1",children:"1"}),` } };
`]})]})}),`
`,e.exports.jsx(s.p,{children:"what we want is something that does the dual of universal quantification, i.e., instead of converting itself to any type, it converts any type to itself. Indeed, this is possible if we apply existential quantification (\u2203) on types."}),`
`,e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-c",children:"// \u2200 type T, Shape converts something of type T to type Shape"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-c",children:"// In other words, given an object of type Shape, \u2203 type T that the Shape object is constructed upon"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"struct"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"Shape"}),` {
`]}),e.exports.jsx(s.span,{className:"code-line",children:`    std::any object = {};
`}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-c",children:"// an existential type is a type that comes with a universally quantified constructor"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-en",children:"Shape"}),"(",e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),`&& x) {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["        ",e.exports.jsx(s.span,{className:"pl-c1",children:"this"}),"->",e.exports.jsx(s.span,{className:"pl-smi",children:"object"})," = std::forward<",e.exports.jsx(s.span,{className:"pl-c1",children:"decltype"}),`(x)>(x);
`]}),e.exports.jsx(s.span,{className:"code-line",children:`    }
`}),e.exports.jsx(s.span,{className:"code-line",children:`};
`}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," objects = std::vector<Shape>{ Rectangle{ .",e.exports.jsx(s.span,{className:"pl-smi",children:"width"})," = ",e.exports.jsx(s.span,{className:"pl-c1",children:"2"})," }, Circle{ .",e.exports.jsx(s.span,{className:"pl-smi",children:"radius"})," = ",e.exports.jsx(s.span,{className:"pl-c1",children:"1"}),` } };
`]})]})}),`
`,e.exports.jsx(s.p,{children:"The immediate consequence of using existentials is that we lose all information of the type that the existential is constructed upon because this information is only available to the constructor of the existential, and the information is lost once we leave the scope of the constructor. This is precisely what we want because it allows us to refer to different types (e.g., Rectangle, Circle, etc.) opaquely, and deal with them uniformly (they are all simply instances of Shape to the outer scope). Note that existentials also allow us to achieve runtime polymorphism in C++ because interactions with existentials do not depend on their underlying type. The polymorphic behavior is therefore preserved even though the compilation process erases all type information of our program."}),`
`,e.exports.jsxs(s.p,{children:["An empty existential type like the ",e.exports.jsx(s.code,{children:"Shape"})," example above is however not very useful, we can't do anything with it! A non-trivial existential type would require us to specify its quantification bound, i.e., the things we can do with it. This is somewhat inconvenient to do, if you're interested, you can check the following example:"]}),`
`,e.exports.jsxs("details",{children:[e.exports.jsx("summary",{children:"A basic but non-trivial existential type"}),e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsxs(s.span,{className:"code-line",children:["#",e.exports.jsx(s.span,{className:"pl-k",children:"include"})," ",e.exports.jsxs(s.span,{className:"pl-s",children:[e.exports.jsx(s.span,{className:"pl-pds",children:"<"}),"any",e.exports.jsx(s.span,{className:"pl-pds",children:">"})]}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["#",e.exports.jsx(s.span,{className:"pl-k",children:"include"})," ",e.exports.jsxs(s.span,{className:"pl-s",children:[e.exports.jsx(s.span,{className:"pl-pds",children:"<"}),"string",e.exports.jsx(s.span,{className:"pl-pds",children:">"})]}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["#",e.exports.jsx(s.span,{className:"pl-k",children:"include"})," ",e.exports.jsxs(s.span,{className:"pl-s",children:[e.exports.jsx(s.span,{className:"pl-pds",children:"<"}),"concepts",e.exports.jsx(s.span,{className:"pl-pds",children:">"})]}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["#",e.exports.jsx(s.span,{className:"pl-k",children:"include"})," ",e.exports.jsxs(s.span,{className:"pl-s",children:[e.exports.jsx(s.span,{className:"pl-pds",children:"<"}),"vector",e.exports.jsx(s.span,{className:"pl-pds",children:">"})]}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["#",e.exports.jsx(s.span,{className:"pl-k",children:"include"})," ",e.exports.jsxs(s.span,{className:"pl-s",children:[e.exports.jsx(s.span,{className:"pl-pds",children:"<"}),"iostream",e.exports.jsx(s.span,{className:"pl-pds",children:">"})]}),`
`]}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"template"}),"<",e.exports.jsx(s.span,{className:"pl-k",children:"typename"})," UnknownType, ",e.exports.jsx(s.span,{className:"pl-k",children:"typename"}),` ReferenceType>
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"concept "}),"SubtypeOf = std::same_as<std::",e.exports.jsx(s.span,{className:"pl-c1",children:"decay_t"}),"<UnknownType>, ReferenceType> || std::derived_from<std::",e.exports.jsx(s.span,{className:"pl-c1",children:"decay_t"}),`<UnknownType>, ReferenceType>;
`]}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"template"}),"<",e.exports.jsx(s.span,{className:"pl-k",children:"typename"})," UnknownType, ",e.exports.jsx(s.span,{className:"pl-k",children:"typename"}),` ...ReferenceTypes>
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"concept "}),`AnyOf = (SubtypeOf<UnknownType, ReferenceTypes> || ...);
`]}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"template"}),"<",e.exports.jsx(s.span,{className:"pl-k",children:"typename"})," UnknownType, ",e.exports.jsx(s.span,{className:"pl-k",children:"typename"}),` ...ReferenceTypes>
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"concept "}),`AnyBut = !AnyOf<UnknownType, ReferenceTypes...>;
`]}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"struct"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"Rectangle"}),` {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"double"})," length = ",e.exports.jsx(s.span,{className:"pl-c1",children:"1"}),`;
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"double"})," width = ",e.exports.jsx(s.span,{className:"pl-c1",children:"1"}),`;
`]}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"toString"}),`() {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["        ",e.exports.jsx(s.span,{className:"pl-k",children:"return"})," ",e.exports.jsxs(s.span,{className:"pl-s",children:[e.exports.jsx(s.span,{className:"pl-pds",children:'"'}),"Rectangle[length: ",e.exports.jsx(s.span,{className:"pl-pds",children:'"'})]})," + ",e.exports.jsx(s.span,{className:"pl-c1",children:"std::to_string"}),"(length) + ",e.exports.jsxs(s.span,{className:"pl-s",children:[e.exports.jsx(s.span,{className:"pl-pds",children:'"'}),", width: ",e.exports.jsx(s.span,{className:"pl-pds",children:'"'})]})," + ",e.exports.jsx(s.span,{className:"pl-c1",children:"std::to_string"}),"(width) + ",e.exports.jsxs(s.span,{className:"pl-s",children:[e.exports.jsx(s.span,{className:"pl-pds",children:'"'}),"]",e.exports.jsx(s.span,{className:"pl-pds",children:'"'})]}),`;
`]}),e.exports.jsx(s.span,{className:"code-line",children:`    }
`}),e.exports.jsx(s.span,{className:"code-line",children:`};
`}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"struct"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"Circle"}),` {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"double"})," radius = ",e.exports.jsx(s.span,{className:"pl-c1",children:"1"}),`;
`]}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"toString"}),`() {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["        ",e.exports.jsx(s.span,{className:"pl-k",children:"return"})," ",e.exports.jsxs(s.span,{className:"pl-s",children:[e.exports.jsx(s.span,{className:"pl-pds",children:'"'}),"Circle[radius: ",e.exports.jsx(s.span,{className:"pl-pds",children:'"'})]})," + ",e.exports.jsx(s.span,{className:"pl-c1",children:"std::to_string"}),"(radius) + ",e.exports.jsxs(s.span,{className:"pl-s",children:[e.exports.jsx(s.span,{className:"pl-pds",children:'"'}),"]",e.exports.jsx(s.span,{className:"pl-pds",children:'"'})]}),`;
`]}),e.exports.jsx(s.span,{className:"code-line",children:`    }
`}),e.exports.jsx(s.span,{className:"code-line",children:`};
`}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"struct"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"Shape"}),` {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"using"})," ToStringSignature = ",e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),`(std::any&)->std::string;
`]}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsx(s.span,{className:"code-line",children:`    std::any object = {};
`}),e.exports.jsxs(s.span,{className:"code-line",children:["    ToStringSignature* toStringFunction = ",e.exports.jsx(s.span,{className:"pl-c1",children:"nullptr"}),`;
`]}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-en",children:"Shape"}),"() = ",e.exports.jsx(s.span,{className:"pl-k",children:"default"}),`;
`]}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-c",children:'// exclude "Shape" itself from the universal quantification'}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-c",children:"// to avoid conflict with the copy/move constructors"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-en",children:"Shape"}),"(AnyBut<Shape> ",e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),`&& x) {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["        ",e.exports.jsx(s.span,{className:"pl-k",children:"using"})," ObjectType = std::",e.exports.jsx(s.span,{className:"pl-c1",children:"decay_t"}),"<",e.exports.jsx(s.span,{className:"pl-c1",children:"decltype"}),`(x)>;
`]}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:["        ",e.exports.jsx(s.span,{className:"pl-c1",children:"this"}),"->",e.exports.jsx(s.span,{className:"pl-smi",children:"object"})," = std::forward<",e.exports.jsx(s.span,{className:"pl-c1",children:"decltype"}),`(x)>(x);
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["        ",e.exports.jsx(s.span,{className:"pl-c1",children:"this"}),"->",e.exports.jsx(s.span,{className:"pl-smi",children:"toStringFunction"})," = [](",e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),"& object) { ",e.exports.jsx(s.span,{className:"pl-k",children:"return"})," std::any_cast<ObjectType&>(object).",e.exports.jsx(s.span,{className:"pl-c1",children:"toString"}),`(); };
`]}),e.exports.jsx(s.span,{className:"code-line",children:`    }
`}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"toString"}),`() {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["        ",e.exports.jsx(s.span,{className:"pl-k",children:"return"})," ",e.exports.jsx(s.span,{className:"pl-c1",children:"toStringFunction"}),`(object);
`]}),e.exports.jsx(s.span,{className:"code-line",children:`    }
`}),e.exports.jsx(s.span,{className:"code-line",children:`};
`}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"main"}),`()->int {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," objects = std::vector<Shape>{ Rectangle{ .",e.exports.jsx(s.span,{className:"pl-smi",children:"width"})," = ",e.exports.jsx(s.span,{className:"pl-c1",children:"2"})," }, Circle{ .",e.exports.jsx(s.span,{className:"pl-smi",children:"radius"})," = ",e.exports.jsx(s.span,{className:"pl-c1",children:"1"}),` } };
`]}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"for"})," (",e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),`& x : objects)
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["        std::cout << x.",e.exports.jsx(s.span,{className:"pl-c1",children:"toString"}),`() << std::endl;
`]}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-c",children:"// you should see that it prints:"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-c",children:"// Rectangle[length: 1.000000, width: 2.000000]"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-c",children:"// Circle[radius: 1.000000]"}),`
`]}),e.exports.jsx(s.span,{className:"code-line",children:`}
`})]})})]}),`
`,e.exports.jsxs(s.p,{children:["Luckily, it is unlikely that you'll need to define your own existential types for the assignments of this course. You'll only deal with one specific kind of existentials: closures, or stateful lambdas in C++ terminology. Stateful lambdas are existentials because they have a hidden state of some unknown type, and we can use ",e.exports.jsx(s.code,{children:"std::function"})," to represent existentials of this kind. Take the light functions in ray tracing for instance, these are all functions that take an intersection position, and return (light direction, light color). Therefore, they can be unified by an existential function type as follows:"]}),`
`,e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"namespace"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"Lights"}),` {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["	",e.exports.jsx(s.span,{className:"pl-c",children:"// Signature: IntersectionPosition -> (LightDirection, LightColor)"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["	",e.exports.jsx(s.span,{className:"pl-k",children:"using"})," Signature = ",e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),"(",e.exports.jsx(s.span,{className:"pl-k",children:"const"}),` glm::vec4&)->std::tuple<glm::vec4, glm::vec3>;
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["	",e.exports.jsx(s.span,{className:"pl-k",children:"using"}),` \u018E = std::function<Signature>;
`]}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:["	",e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"Point"}),"(",e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),"&& Position, ",e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),"&& Color, ",e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),`&& AttenuationFunction) {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["		",e.exports.jsx(s.span,{className:"pl-k",children:"return"})," [=](",e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),"&& IntersectionPosition) { ",e.exports.jsx(s.span,{className:"pl-c",children:"/* ... */"}),` };
`]}),e.exports.jsx(s.span,{className:"code-line",children:`	}
`}),e.exports.jsxs(s.span,{className:"code-line",children:["	",e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"Directional"}),"(",e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),"&& Direction, ",e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),`&& Color) {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["		",e.exports.jsx(s.span,{className:"pl-k",children:"return"})," [=](",e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),"&& IntersectionPosition) { ",e.exports.jsx(s.span,{className:"pl-c",children:"/* ... */"}),` };
`]}),e.exports.jsx(s.span,{className:"code-line",children:`	}
`}),e.exports.jsxs(s.span,{className:"code-line",children:["	",e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"Spot"}),"(",e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),"&& Position, ",e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),"&& Axis, ",e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," \u03B8, ",e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," Penumbra, ",e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),"&& Color, ",e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),`&& AttenuationFunction) {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["		",e.exports.jsx(s.span,{className:"pl-k",children:"return"})," [=](",e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),"&& IntersectionPosition) { ",e.exports.jsx(s.span,{className:"pl-c",children:"/* ... */"}),` };
`]}),e.exports.jsx(s.span,{className:"code-line",children:`	}
`}),e.exports.jsx(s.span,{className:"code-line",children:`}
`}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," LightSources = std::vector<Lights::\u018E>{ ",e.exports.jsx(s.span,{className:"pl-c1",children:"Lights::Point"}),"(...), ",e.exports.jsx(s.span,{className:"pl-c1",children:"Lights::Directional"}),"(...), ",e.exports.jsx(s.span,{className:"pl-c1",children:"Lights::Spot"}),`(...), ... };
`]}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"for"})," (",e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),`& Light : LightSources) {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["	",e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," [LightDirection, LightColor] = ",e.exports.jsx(s.span,{className:"pl-c1",children:"Light"}),`(IntersectionPosition);
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["	",e.exports.jsx(s.span,{className:"pl-c",children:"// do something with LightDirection and LightColor"}),`
`]}),e.exports.jsx(s.span,{className:"code-line",children:`}
`})]})}),`
`,e.exports.jsxs(s.p,{children:["There is another way to achieve runtime polymorphism in C++: ",e.exports.jsx(s.a,{href:"https://en.cppreference.com/w/cpp/language/virtual",target:"_blank",rel:"noopener noreferrer",children:"virtual functions"}),". It is however considerably more restrictive than existentials and therefore not as commonly used in modern C++. Virtual functions are intrusive, using them will make your types lose value semantics and they force you to think top-down (define an interface first, then implement the interface for concrete types), while existentials allow us to think bottom-up (start from simple concrete types, define an abstract existential type later if ever needed). Depending on how we approach the problem, existentials might be easier to reason with."]}),`
`,e.exports.jsx(l,{})]})]})}function p(n={}){const{wrapper:s}=n.components||{};return s?e.exports.jsx(s,Object.assign({},n,{children:e.exports.jsx(a,n)})):a(n)}export{p as default,t as documentProps};
